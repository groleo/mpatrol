EXAMPLES FOR THE MPATROL LIBRARY


This document contains a set of examples that are intended to illustrate what
exactly is possible with the mpatrol library and how to go about using it
effectively.

You should already have built and installed the library and should know how to
link programs with the library.  Unfortunately I can't give specific
instructions on how to do this as it varies from system to system and also
depends on your preferred compiler and development tools.

However, on a typical SVR4 UNIX system, with mpatrol installed in /usr/local,
the mpatrol library can usually be incorporated into a program using the
following commands:

    If the mpatrol library was built with no support for any object file format
    or was built with support for the COFF object file format:

        cc -I/usr/local/include <file> -L/usr/local/lib -lmpatrol

    If the mpatrol library was built with support for the ELF32 object file
    format access library:

        cc -I/usr/local/include <file> -L/usr/local/lib -lmpatrol -lelf

    If the mpatrol library was built with support for the GNU BFD object file
    format access library:

        cc -I/usr/local/include <file> -L/usr/local/lib -lmpatrol -lbfd -liberty

You should also know how to set an environment variable on your specific system.
Again, this varies from system to system and also depends on the command line
interpreter or shell that you use.  The environment variable that the mpatrol
library uses is called MPATROL_OPTIONS.  You can see exactly what options are
available for this environment variable by setting it to HELP and then running
a program that has been linked with the library.


Example 1
=========

    The first example we'll look at is when the argument in a call to free()
    doesn't match the return value from malloc(), even though the intention is
    to free the memory that was allocated by malloc().  This example is in
    tests/fail/test1.c and causes many existing malloc() implementations to
    crash.

    Along the way, I'll try to describe as many features of the mpatrol library
    as possible, and illustrate them with examples.  Note that the output from
    your version of the library is likely to vary slightly from that shown in
    the examples, especially on non-UNIX systems.

    ----------------------------------------------------------------------------
23  /*
24   * Allocates a block of 16 bytes and then attempts to free the memory
25   * returned at an offset of 1 byte into the block.
26   */


29  #include "mpatrol.h"


32  int main(void)
33  {
34      char *p;

36      if (p = (char *) malloc(16))
37          free(p + 1);
38      return EXIT_SUCCESS;
39  }
    ----------------------------------------------------------------------------

    Note that I've removed the copyright message from the start of the file and
    added line numbers so that the tracing below makes more sense.

    After compiling and linking the above program with the mpatrol library, the
    MPATROL_OPTIONS environment variable should be set to be LOGALL and the
    program should be executed, generating the following output in mpatrol.log.

    ----------------------------------------------------------------------------
    @(#) mpatrol 1.0.0 (99/10/11)
    Copyright (C) 1997-1999 Graeme S. Roy

    This is free software, and you are welcome to redistribute it under certain
    conditions; see the GNU Library General Public License for details.

    ALLOC: malloc (13, 16 bytes, 8 bytes) [main|test1.c|36]
            0x00010AE0 main
            0x000109D4 _start

    returns 0x00028000

    FREE: free (0x00028001) [main|test1.c|37]
            0x00010B24 main
            0x000109D4 _start

    ERROR: free: 0x00028001 does not match allocation of 0x00028000
        0x00028000 (16 bytes) {malloc:13:0} [main|test1.c|36]
            0x00010AE0 main
            0x000109D4 _start

    system page size:  8192 bytes
    default alignment: 8 bytes
    overflow size:     0 bytes
    overflow byte:     0xAA
    allocation byte:   0xFF
    free byte:         0x55
    allocation stop:   0
    reallocation stop: 0
    free stop:         0
    unfreed abort:     0
    prologue function: <unset>
    epilogue function: <unset>
    handler function:  <unset>
    log file:          mpatrol.log
    program filename:  /proc/729/object/a.out
    symbols read:      3240
    allocation count:  13
    allocation peak:   4720 bytes
    allocation limit:  0 bytes
    allocated blocks:  1 (16 bytes)
    freed blocks:      0 (0 bytes)
    free blocks:       1 (8176 bytes)
    internal blocks:   25 (204800 bytes)
    total heap usage:  212992 bytes
    total warnings:    0
    total errors:      1
    ----------------------------------------------------------------------------

    Ignoring the copyright blurb at the top, let's first take a look at the
    initial log message from the library.  I've annotated each of the items with
    a number that corresponds to the descriptions below.

    ----------------------------------------------------------------------------
     (1)    (2)   (3)    (4)       (5)     (6)    (7)  (8)
      |      |     |      |         |       |      |    |
      V      V     V      V         V       V      V    V
    ALLOC: malloc (13, 16 bytes, 8 bytes) [main|test1.c|36]
     (9) -> 0x00010AE0 main
            0x000109D4 _start <- (10)

    returns 0x00028000 <- (11)
    ----------------------------------------------------------------------------

     1. Allocation type.  This generalises the type of dynamic memory operation
        that is being performed, and can be one of `ALLOC', `REALLOC' or `FREE'.
        This should make looking for all allocations, reallocations or frees in
        the log file a lot easier.

     2. Allocation function.  This is the name of the function that has been
        called to allocate the memory, in this case malloc.

     3. Allocation index.  This is incremented every time a new memory
        allocation is requested, and persists even if the memory allocation is
        resized with realloc() or recalloc(), so can be useful to keep track of
        a memory allocation, even if its start address changes.  The mpatrol
        library may use up the first few allocation indices when it gets
        initialised.

     4. Size of requested allocation.

     5. Alignment for requested allocation.  This is normally the default system
        alignment for general-purpose memory allocations, but may be different
        depending on the type of function that is used to allocate the memory.

    The following information contains source file details of where the call to
    malloc() came from, but is only available if the source file containing the
    call to malloc() included mpatrol.h; otherwise the fields will all be `-'.
    Note that calls to the C++ operators currently do not contain this
    information since they cannot be rewritten as preprocessor macros.

     6. Function where call to malloc() took place.  This information is only
        available if the source file containing the call to malloc() was
        compiled with gcc or g++.

     7. Filename in which call to malloc() took place.

     8. Line number at which call to malloc() took place.

    The following information contains function call stack details of where the
    call to malloc() came from, but is only available if the mpatrol library has
    been built on a platform that supports this.  The top-most entry should be
    the function which called malloc() and the bottom-most entry should be the
    entry-point for the process.

     9. Address of function call.  This is normally the address of the machine
        instruction immediately after the function call instruction, also known
        as the return address.

    10. Function where call took place.  This information is only available if
        the mpatrol library has been built on a platform that supports reading
        symbol table information from executable files, and then only if there
        is an entry in the symbol table corresponding to the return address.
        C++ function names may still be in their mangled form, but this can be
        easily rectified by processing the log file with a C++ name demangler.

    The following information is only available when the allocation type is
    `ALLOC' or `REALLOC' since it makes no sense when applied to `FREE'.

    11. The address of the new memory block that has been allocated by malloc().

    As you can see, there is quite a lot of information that can be displayed
    from a simple call to malloc(), and hopefully this information has been
    presented in a clear and concise format in the log file.

    The next entries in the log file correspond to the call to free(), which
    attempts to free the memory allocated by malloc(), but supplies the wrong
    address.

    The first three lines should be self-explanatory as they are very similar
    to those described above for malloc().  However, the next lines signal that
    a terminal error has occurred in the program, so I've annotated them as
    before.

    ----------------------------------------------------------------------------
    FREE: free (0x00028001) [main|test1.c|37]
            0x00010B24 main
            0x000109D4 _start

     (1)   (2)
      |     |
      V     V
    ERROR: free: 0x00028001 does not match allocation of 0x00028000
           (3)        (4)       (5)  (6)(7)  (8)    (9)  (10)
            |          |         |    |  |    |      |    |
            V          V         V    V  V    V      V    V
        0x00028000 (16 bytes) {malloc:13:0} [main|test1.c|36]
    (11) -> 0x00010AE0 main
            0x000109D4 _start
    ----------------------------------------------------------------------------

     1. Error severity.  The mpatrol library has two different severities of
        error: `WARNING' and `ERROR'.  The first is always recoverable, and
        serves only to indicate that something is not quite right, and so may
        be useful in determining where something started to go wrong.  The
        second may or may not be recoverable, and the library terminates the
        program if it is fatal, displaying any relevant information as it does
        this.

     2. Allocation function.  This is the name of the function used to allocate,
        reallocate or free memory where the error was detected.  This may be
        omitted if an error is detected elsewhere in the library.

    The following information is related to the information that the library
    has stored about the relevant memory allocation.  This information is always
    displayed in this format when details of individual memory allocations are
    required.  If any information is missing then it simply means that the
    library was not able to determine it when the memory block was first
    allocated.

     3. Address of memory allocation.

     4. Size of memory allocation.

     5. Allocation function.  This is the name of the function that was called
        to allocate the memory block, in this case malloc.  If the memory
        allocation has been resized then this will be either realloc or
        recalloc.

     6. Allocation index.

     7. Reallocation index.  This is used to count the number of times a memory
        allocation has been resized with realloc() or recalloc().

     8. Function where original call to malloc() took place.  If the memory
        allocation has been resized then this will be the name of the function
        which last called realloc() or recalloc().

     9. Filename in which original call to malloc() took place.  If the memory
        allocation has been resized then this will be the filename in which the
        last call to realloc() or recalloc() took place.

    10. Line number at which original call to malloc() took place.  If the
        memory allocation has been resized then this will be the line number at
        which the last call to realloc() or recalloc() took place.

    11. Function call stack of original memory allocation.  If the memory
        allocation has been resized then this will be the call stack of the
        last call to realloc() or recalloc().

    So, the mpatrol library detected the error in the above program and
    terminated it.  When the library terminates it always displays a summary of
    various memory allocation statistics and settings that were used during the
    execution of the program.

    The various settings and statistics displayed by the library for the above
    example have been numbered and their descriptions appear below.

    ----------------------------------------------------------------------------
 1  system page size:  8192 bytes
 2  default alignment: 8 bytes
 3  overflow size:     0 bytes
 4  overflow byte:     0xAA
 5  allocation byte:   0xFF
 6  free byte:         0x55
 7  allocation stop:   0
 8  reallocation stop: 0
 9  free stop:         0
10  unfreed abort:     0
11  prologue function: <unset>
12  epilogue function: <unset>
13  handler function:  <unset>
14  log file:          mpatrol.log
15  program filename:  /proc/729/object/a.out
16  symbols read:      3240
17  allocation count:  13
18  allocation peak:   4720 bytes
19  allocation limit:  0 bytes
20  allocated blocks:  1 (16 bytes)
21  freed blocks:      0 (0 bytes)
22  free blocks:       1 (8176 bytes)
23  internal blocks:   25 (204800 bytes)
24  total heap usage:  212992 bytes
25  total warnings:    0
26  total errors:      1
    ----------------------------------------------------------------------------

     1. System page size.  This value is used on some platforms when allocating
        and protecting system memory.

     2. Default alignment.  This value is the minimum alignment required for
        general purpose memory allocations, and is usually the alignment
        required by the most restrictive datatype on a given system.  It is used
        when allocating memory that has no specified alignment.  It can be
        changed at run-time using the DEFALIGN option, but setting this value
        too small may cause the program to crash due to bus errors which are
        caused by reading from or writing to misaligned data.

     3. Overflow size.  This value is the size used by one overflow buffer.  If
        this is non-zero then every memory allocation will have two overflow
        buffers; one on either side.  These buffers are used by the library to
        detect if the program has written too many bytes to a memory allocation,
        thus overflowing into one of the buffers, but these extra checks can
        slow down execution speed.  It can be changed at run-time using the
        OFLOWSIZE option.

     4. Overflow byte.
     5. Allocation byte.
     6. Free byte.  These values are used by the library to pre-fill blocks of
        memory for checking purposes.  The overflow byte is used to fill
        overflow buffers, the allocation byte is used to fill newly-allocated
        memory (except from calloc() or recalloc()), and the free byte is used
        to fill free blocks or freed memory allocations.  These can be changed
        at run-time using the OFLOWBYTE, ALLOCBYTE and FREEBYTE options.

     7. Allocation stop.
     8. Reallocation stop.
     9. Free stop.  These values are used by the library to halt the program
        when run inside a debugger whenever a specified allocation index is
        allocated, reallocated or freed.  These can be changed at run-time using
        the ALLOCSTOP, REALLOCSTOP and FREESTOP options.

    10. Unfreed abort.  This value is used when the program terminates and is
        used by the library to check if there are more than a given number of
        unfreed memory allocations.  If there are then the library will cause
        the program to abort with an error.  It can be changed at run-time using
        the UNFREEDABORT option.

    11. Prologue function.
    12. Epilogue function.
    13. Handler function.  These values contain addresses or names of functions
        that have been installed as callback functions for the library.  These
        functions, if set, will be called from the library at appropriate times
        during program execution in order to handle specific events.  These can
        be changed at compile-time using the __mp_prologue(), __mp_epilogue()
        and __mp_nomemory() functions.

    14. Log file.  Simply contains the name of the file where all mpatrol
        library diagnostics go to.  It can be changed at run-time using the
        LOGFILE option.

    15. Program filename.  Contains the full pathname to the program's
        executable file.  This is used by the mpatrol library to read the
        symbol table in order to provide symbolic information in function call
        stacks.  It can be changed at run-time using the PROGFILE option.

    16. Symbols read.  This value contains the total number of symbols read
        from a program's executable file and/or the dynamic linker, if
        applicable.

    17. Allocation count.  This value contains the total number of memory
        allocations that were created by the mpatrol library.  This value may
        be more than expected if the mpatrol library makes any memory
        allocations during initialisation.

    18. Allocation peak.  This value contains the peak memory usage set by the
        program when running.  This value may be more than expected if the
        mpatrol library makes any memory allocations during initialisation.

    19. Allocation limit.  This value is used to limit the amount of memory
        that can be allocated by a program, which can be useful for
        stress-testing in simulated low memory conditions.  It can be changed
        at run-time using the LIMIT option.

    20. Allocated blocks.
    21. Freed blocks.
    22. Free blocks.  These values contain the total number of allocated, freed
        and free blocks at the time the summary was produced.  A freed block is
        an allocated block that has been freed but has not been returned to the
        free memory list for later allocation.  These values may be different
        from those expected if the mpatrol library makes any memory allocations
        during initialisation.

    23. Internal blocks.  This value contains the total number of memory blocks
        (of varying sizes) that have been allocated from the system for the
        mpatrol library to use internally.  These memory blocks will be
        write-protected on systems that support memory protection in order to
        prevent the program from corrupting the library's data structures.  This
        can be overridden at run-time using the NOPROTECT option in order to
        speed up program execution slightly.

    24. Total heap usage.  This value contains the total amount of system heap
        memory that has been allocated by the mpatrol library.

    25. Total warnings.
    26. Total errors.  The library keeps a count of the total number of warnings
        and errors it has displayed so that you can quickly work out this
        information at program termination.


Example 2
=========

    The next example uses tests/fail/test2.c to illustrate how the mpatrol
    library can detect whereabouts on the heap an address belongs.

    ----------------------------------------------------------------------------
23  /*
24   * Allocates a block of 16 bytes and then immediately frees it.  An
25   * attempt is then made to double the size of the original block.
26   */


29  #include "mpatrol.h"


32  int main(void)
33  {
34      char *p;

36      if (p = (char *) malloc(16))
37      {
38          free(p);
39          p = (char *) realloc(p, 32);
40      }
41      return EXIT_SUCCESS;
42  }
    ----------------------------------------------------------------------------

    The relevant excerpts from mpatrol.log appear below.  The format of the log
    messages should be familiar to you now.

    ----------------------------------------------------------------------------
    ALLOC: malloc (13, 16 bytes, 8 bytes) [main|test2.c|36]
            0x00010B18 main
            0x00010A0C _start

    returns 0x00028000

    FREE: free (0x00028000) [main|test2.c|38]
            0x00010B54 main
            0x00010A0C _start

        0x00028000 (16 bytes) {malloc:13:0} [main|test2.c|36]
            0x00010B18 main
            0x00010A0C _start

    REALLOC: realloc (0x00028000, 32 bytes, 8 bytes) [main|test2.c|39]
            0x00010B88 main
            0x00010A0C _start

    ERROR: realloc: 0x00028000 has not been allocated

    returns 0x00000000
    ----------------------------------------------------------------------------

    The mpatrol library stores all of its information about allocated and free
    memory in tree structures so that it can quickly determine if an address
    belongs to allocated or free memory, or if it even exists in the heap that
    is managed by mpatrol.  The above example should illustrate this since
    after the allocation had been freed, the library recognised this and
    reported an error.  It was possible for the program to continue execution
    even after that error since mpatrol could recover from it and return NULL.

    It is possible for mpatrol to give even more useful diagnostics in the above
    situation by using the NOFREE option.  This prevents the library from
    returning any freed allocations to the free memory pool, by preserving any
    information about them and marking them as freed.  If you add the NOFREE
    option to the MPATROL_OPTIONS environment variable you should see the
    following entries in mpatrol.log instead.

    ----------------------------------------------------------------------------
    ALLOC: malloc (13, 16 bytes, 8 bytes) [main|test2.c|36]
            0x00010B18 main
            0x00010A0C _start

    returns 0x00029DE0

    FREE: free (0x00029DE0) [main|test2.c|38]
            0x00010B54 main
            0x00010A0C _start

        0x00029DE0 (16 bytes) {malloc:13:0} [main|test2.c|36]
            0x00010B18 main
            0x00010A0C _start

    REALLOC: realloc (0x00029DE0, 32 bytes, 8 bytes) [main|test2.c|39]
            0x00010B88 main
            0x00010A0C _start

    ERROR: realloc: 0x00029DE0 was freed with free
        0x00029DE0 (16 bytes) {free:13:0} [main|test2.c|38]
            0x00010B54 main
            0x00010A0C _start

    returns 0x00000000
    ----------------------------------------------------------------------------

    Note the extra information reported by realloc() since the library knows
    all of the details about the freed memory allocation and when it was freed.

    The NOFREE option tends to use up much more system memory than normal since
    it effectively instructs the mpatrol library to allocate new memory for
    every single memory allocation or reallocation.  It can also slow down
    program execution when overflow buffers are used, since with each new memory
    allocation the library needs to check more and more overflow buffers every
    time it is called.  However, it can be quite useful for problems such as
    this one.  The test in tests/fail/test3.c has a similar situation.

    Normally, the NOFREE option will cause the library to fill all freed memory
    allocations with the free byte.  However, the original contents of such
    allocations can be preserved with the PRESERVE option.  This could help in
    situations when you need to determine exactly if a program is relying on the
    contents of freed memory.


Example 3
=========

    This next example illustrates how the mpatrol library is able to check to
    see if anything has been written into free memory.  The test is located in
    tests/fail/test4.c and simply writes a single byte into free memory.

    ----------------------------------------------------------------------------
23  /*
24   * Allocates a block of 16 bytes and then immediately frees it.  A NULL
25   * character is then written into the middle of the freed memory.
26   */


29  #include "mpatrol.h"


32  int main(void)
33  {
34      char *p;

36      if (p = (char *) malloc(16))
37      {
38          free(p);
39          p[8] = '\0';
40      }
41      return EXIT_SUCCESS;
42  }
    ----------------------------------------------------------------------------

    The following output was produced as part of mpatrol.log.  Note that this
    test was run using the same MPATROL_OPTIONS settings as the last example,
    but make sure that PRESERVE is not set.

    ----------------------------------------------------------------------------
    ERROR: freed allocation 0x00029DE0 has memory corruption at 0x00029DE8
            0x00029DE8  00555555 55555555                    .UUUUUUU

        0x00029DE0 (16 bytes) {free:13:0} [main|test4.c|38]
            0x00010B1C main
            0x000109D4 _start
    ----------------------------------------------------------------------------

    The library was able to detect that something had been written into free
    memory and could report on the memory allocation that was overwritten.
    However, these checks are only performed whenever a function in the mpatrol
    library is called.  In the example above, the code which wrote into free
    memory could have been miles away from where the library detected the error.

    On platforms that support memory protection, the library also supports the
    PAGEALLOC option.  This option instructs the library to force every single
    memory allocation to have a size which is a multiple of the system page
    size.  Although the library still stores the original requested size, it
    effectively means that no two memory allocations occupy the same page of
    memory.  It can then use page protection (which only operates on pages of
    memory) to protect all free memory from being read from or written to, and
    uses similar features to install a page of overflow buffer on either side of
    the allocation.

    However, if the requested size for the memory allocation was not a multiple
    of the page size this means that there will still be unused space left over
    in the allocated pages.  This problem is solved by turning the unused space
    into overflow buffers that will be checked in the normal way.  The
    positioning of the allocation within its pages is also important.  If you
    want to check for illegal reads from the borders of the memory allocation,
    unless it fits exactly into its pages then there is a chance that a program
    could illegally read the right-most overflow buffer if the allocation was
    left-aligned, or vice-versa.  Two settings therefore exist for the PAGEALLOC
    option: LOWER and UPPER.  They refer to the placement of every memory
    allocation within its constituent pages.

    The following diagram illustrates the PAGEALLOC option.  In the diagram, the
    system page size is assumed to be 16 bytes (very unlikely, but will serve
    for this example) and each character represents 1 byte.

    ----------------------------------------------------------------------------
    x = allocated memory
    o = overflow buffer (filled with the overflow byte)
    . = overflow buffer page (read and write protected)

    PAGEALLOC=LOWER, allocation size is 16 bytes or
    PAGEALLOC=UPPER, allocation size is 16 bytes:
        ................xxxxxxxxxxxxxxxx................

    PAGEALLOC=LOWER, allocation size is 8 bytes:
        ................xxxxxxxxoooooooo................

    PAGEALLOC=UPPER, allocation size is 8 bytes:
        ................ooooooooxxxxxxxx................
    ----------------------------------------------------------------------------

    In our original example, if the PAGEALLOC=LOWER option is added to the
    MPATROL_OPTIONS environment variable then the following error will be
    produced instead of the original error.

    ----------------------------------------------------------------------------
    ERROR: illegal memory access at address 0x0009E008
        0x0009E000 (16 bytes) {free:13:0} [main|test4.c|38]
            0x00010B1C main
            0x000109D4 _start

        call stack
            0x00010B1C main
            0x000109D4 _start
    ----------------------------------------------------------------------------

    On systems that support memory protection, the mpatrol library has a
    built-in signal handler which catches illegal memory accesses and
    terminates the program.  In the above case, the freed memory was made
    write-protected and so could not be written to.  The underlying virtual
    memory system in the operating system noticed this and signaled this to the
    library immediately after it happened.

    Along with the details of the freed memory allocation that was being
    written to, the library also attempts to display the function call stack
    for the location in the program that caused the illegal memory access,
    although this can be quite unreliable.  A better solution would be to run
    the program in a debugger to catch the illegal memory access.

    Note that the PAGEALLOC option also modifies the behaviour of the NOFREE
    and PRESERVE options when used together.  The memory allocation being freed
    will always be made write-protected when the PRESERVE option is used,
    otherwise it will also be made read-protected to prevent further accesses.

    Note also that the PAGEALLOC=UPPER option is potentially much less efficient
    at catching illegal memory accesses than the PAGEALLOC=LOWER option.  This
    is due to alignment requirements, since an allocation of 1 byte requiring an
    alignment of 16 bytes cannot be placed at the very end of a page of size
    4096 bytes.  The following diagram illustrates this, using the same page
    size as the last diagram.

    ----------------------------------------------------------------------------
    x = allocated memory
    o = overflow buffer (filled with the overflow byte)
    . = overflow buffer page (read and write protected)

    PAGEALLOC=UPPER, allocation size is 16 bytes, alignment is 8 bytes:
        ................xxxxxxxxxxxxxxxx................

    PAGEALLOC=UPPER, allocation size is 3 bytes, alignment is 1 byte:
        ................oooooooooooooxxx................

    PAGEALLOC=UPPER, allocation size is 3 bytes, alignment is 8 bytes:
        ................ooooooooxxxooooo................
    ----------------------------------------------------------------------------

    Everything is OK until the last allocation, where the alignment requirement
    means that there must be two overflow buffers.  This slows down program
    execution since the library must check an additional overflow buffer, and
    also means that the program would have to read six bytes beyond the end of
    the allocation before the illegal memory access would be detected.


Example 4
=========

    This example illustrates the use of overflow buffers and so the
    MPATROL_OPTIONS environment variable should have OFLOWSIZE=2 added to it.
    However, turn off any PAGEALLOC options for the purposes of this example.
    The test is located in tests/fail/test5.c, and tests/fail/test6.c is very
    similar.

    ----------------------------------------------------------------------------
23  /*
24   * Allocates a block of 16 bytes and then copies a string of 16 bytes
25   * into the block.  However, the string is copied to 1 byte before the
26   * allocated block which writes before the start of the block.  This test
27   * must be run with an OFLOWSIZE greater than zero.
28   */


31  #include "mpatrol.h"


34  int main(void)
35  {
36      char *p;

38      if (p = (char *) malloc(16))
39      {
40          strcpy(p - 1, "this test fails!");
41          free(p);
42      }
43      return EXIT_SUCCESS;
44  }
    ----------------------------------------------------------------------------

    The following error should be produced in mpatrol.log.

    ----------------------------------------------------------------------------
    ERROR: allocation 0x00029E28 has a corrupted overflow buffer at 0x00029E27
            0x00029E26  AA74                                 ªt

        0x00029E28 (16 bytes) {malloc:13:0} [main|test5.c|38]
            0x00010B0C main
            0x00010A00 _start
    ----------------------------------------------------------------------------

    Once again, the library attempts to show you as much detail as possible
    about where the corruption occurred.  Along with showing you a memory dump
    of the overflow buffer that was corrupted, it also shows you the allocation
    to which the overflow buffer belongs.

    Using overflow buffers can reduce the speed of program execution since the
    library has to check every buffer whenever it is called, and if the buffers
    are larger then they'll take longer to check and will use up more memory.
    However, larger buffers mean that there is less chance of the program
    writing past one memory allocation into another.

    On systems which support software watch points, there is an extra option
    called OFLOWWATCH which allows additional memory protection.  Watch points
    allow individual bytes to be read and/or write protected as opposed to just
    pages.  The OFLOWWATCH option installs software watch points at every
    overflow buffer instead of requiring the library to check the integrity of
    the overflow buffers, and can be used in combination with PAGEALLOC.
    However, software watch points slow down program execution to a crawl since
    every machine instruction must be checked individually by the system to see
    if it accesses a watch point area.  Slowing the program down by a factor of
    10,000 is not uncommon on some systems when the OFLOWWATCH option is used.


Example 5
=========

    This example illustrates how the mpatrol library checks for calls to
    incompatible pairs of memory allocation functions.  It requires the use of
    C++, although does not use any C++ features except for overloaded operators.
    The source is in tests/fail/test7.c, and tests/fail/test8.c is similar.

    ----------------------------------------------------------------------------
23  /*
24   * Allocates a block of 16 bytes using C++ operator new[] and then attempts
25   * to free it using C++ operator delete.  This is a C++-only test.
26   */


29  #include "mpatrol.h"


32  int main(void)
33  {
34      char *p;

36      p = new char[16];
37      delete p;
38      return EXIT_SUCCESS;
39  }
    ----------------------------------------------------------------------------

    The relevant parts of mpatrol.log are shown below.

    ----------------------------------------------------------------------------
    ALLOC: operator new[] (17, 16 bytes, 8 bytes) [-|-|-]
            0x00010A28 __builtin_vec_new
            0x00010ADC main
            0x000108D0 _start

    returns 0x00028000

    FREE: operator delete (0x00028000) [-|-|-]
            0x00010A74 __builtin_delete
            0x00010AF0 main
            0x000108D0 _start

    ERROR: operator delete: 0x00028000 was allocated with operator new[]
        0x00028000 (16 bytes) {operator new[]:17:0} [-|-|-]
            0x00010A28 __builtin_vec_new
            0x00010ADC main
            0x000108D0 _start
    ----------------------------------------------------------------------------

    This shows a call to operator new[], closely followed by a call to
    operator delete.  However, in C++ calls to operator new[] must be matched
    by calls to operator delete[] and not operator delete.  Hence, the library
    reports this as an error and does not free the memory allocation.


Example 6
=========

    This last example illustrates the various SHOW options that are available
    for displaying additional information from the mpatrol library at program
    termination.  It also shows how to easily detect memory leaks.  Use the
    OFLOWSIZE=16, NOFREE and SHOWALL options in MPATROL_OPTIONS before running.

    ----------------------------------------------------------------------------
 1  /*
 2   * Introduces a memory leak by clobbering a pointer with a new memory
 3   * allocation.  Use with SHOWUNFREED to display the unfreed allocation.
 4   */


 7  #include "mpatrol.h"


10  int main(void)
11  {
12      void *p;

14      p = malloc(4);
15      p = malloc(4);
16      if (p != NULL)
17          free(p);
18      return EXIT_SUCCESS;
19  }
    ----------------------------------------------------------------------------

    The information that we are interested in comes after the summary of library
    statistics generated in the log file.  The first block of data shows a
    memory map of the heap that is being handled by mpatrol.  This can be used
    to see graphically where a particular allocation is located, or to look for
    memory fragmentation.  The SHOWMAP option also displays this information.

    Note that gaps in the memory map can either be due to space used by internal
    memory blocks or to some other memory allocation library using up space.
    On some systems that don't have virtual memory, gaps are likely to be owned
    by other processes or belong to the system free memory list.

    ----------------------------------------------------------------------------
    memory map:
      / 0x8000A000-0x8000A00F overflow (16 bytes)
     |+ 0x8000A010-0x8000A077 allocated (104 bytes) {malloc:1:0} [-|-|-]
      \ 0x8000A078-0x8000A087 overflow (16 bytes)
      / 0x8000A088-0x8000A097 overflow (16 bytes)
     |+ 0x8000A098-0x8000A115 freed (126 bytes) {free:2:0} [-|-|-]
      \ 0x8000A116-0x8000A125 overflow (16 bytes)
      / 0x8000A126-0x8000A135 overflow (16 bytes)
     |+ 0x8000A136-0x8000AF05 freed (3536 bytes) {free:3:0} [-|-|-]
      \ 0x8000AF06-0x8000AF15 overflow (16 bytes)
      / 0x8000AF16-0x8000AF25 overflow (16 bytes)
     |+ 0x8000AF26-0x8000AFA3 freed (126 bytes) {free:4:0} [-|-|-]
      \ 0x8000AFA4-0x8000AFB3 overflow (16 bytes)
      / 0x8000AFB4-0x8000AFC3 overflow (16 bytes)
     |+ 0x8000AFC4-0x8000AFC7 allocated (4 bytes) {malloc:10:0} [main|test.c|14]
      \ 0x8000AFC8-0x8000AFD7 overflow (16 bytes)
      / 0x8000AFD8-0x8000AFE7 overflow (16 bytes)
     |+ 0x8000AFE8-0x8000AFEB freed (4 bytes) {free:11:0} [main|test.c|17]
      \ 0x8000AFEC-0x8000AFFB overflow (16 bytes)
    --- 0x8000AFFC-0x8000AFFF free (4 bytes)
        --------------------- gap (12288 bytes)
      / 0x8000E000-0x8000E00F overflow (16 bytes)
     |+ 0x8000E010-0x8000EA27 freed (2584 bytes) {free:5:0} [-|-|-]
      \ 0x8000EA28-0x8000EA37 overflow (16 bytes)
      / 0x8000EA38-0x8000EA47 overflow (16 bytes)
     |+ 0x8000EA48-0x8000EAC5 freed (126 bytes) {free:6:0} [-|-|-]
      \ 0x8000EAC6-0x8000EAD5 overflow (16 bytes)
      / 0x8000EAD6-0x8000EAE5 overflow (16 bytes)
     |+ 0x8000EAE6-0x8000EB63 freed (126 bytes) {free:8:0} [-|-|-]
      \ 0x8000EB64-0x8000EB73 overflow (16 bytes)
    --- 0x8000EB74-0x8000EFFF free (1164 bytes)
        --------------------- gap (8192 bytes)
      / 0x80011000-0x8001100F overflow (16 bytes)
     |+ 0x80011010-0x800127F7 freed (6120 bytes) {free:7:0} [-|-|-]
      \ 0x800127F8-0x80012807 overflow (16 bytes)
    --- 0x80012808-0x80012FFF free (2040 bytes)
        --------------------- gap (106496 bytes)
      / 0x8002D000-0x8002D00F overflow (16 bytes)
     |+ 0x8002D010-0x8002DBBF freed (2992 bytes) {free:9:0} [-|-|-]
      \ 0x8002DBC0-0x8002DBCF overflow (16 bytes)
    --- 0x8002DBD0-0x8002DFFF free (1072 bytes)
    ----------------------------------------------------------------------------

    The next block of data shows a summary of all the symbols that could be read
    from the program's executable file and/or any shared libraries that the
    program requires.  This can be useful to see which symbols have actually
    been read by the mpatrol library.  The SHOWSYMBOLS option also displays this
    information.

    Note that the following data has been dramatically cut down in size for the
    purposes of this example.  The `...' marks text that has been removed.

    ----------------------------------------------------------------------------
    symbols read: 2438
        0x8000076C-0x800007D9 _init [/proc/789/exe] (110 bytes)
        0x80000900-0x8000094F _start [/proc/789/exe] (80 bytes)
        0x80000950-0x8000096F __do_global_dtors_aux [/proc/789/exe] (32 bytes)
        0x80000970-0x80000977 fini_dummy [/proc/789/exe] (8 bytes)
        ...
        0x80003B24-0x80003B4B __clear_cache [/proc/789/exe] (40 bytes)
        0x80003B4C-0x80003B6F __do_global_ctors_aux [/proc/789/exe] (36 bytes)
        0x80003B70-0x80003B77 init_dummy [/proc/789/exe] (8 bytes)
        0x80003B78-0x80003BA9 _fini [/proc/789/exe] (50 bytes)
        0xC0002604-0xC0002609 _start [/lib/ld.so.1] (6 bytes)
        0xC000260A-0xC0002659 _dl_start_user [/lib/ld.so.1] (80 bytes)
        0xC000265A-0xC0002B1B _dl_start [/lib/ld.so.1] (1218 bytes)
                   0xC000266A here [/lib/ld.so.1] (0 bytes)
        ...
        0xC0007A78-0xC0007AB5 __libc_read [/lib/ld.so.1] (62 bytes)
                   0xC0007A78 read [/lib/ld.so.1] (0 bytes)
                   0xC0007A9A __syscall_error [/lib/ld.so.1] (0 bytes)
        0xC0007AB8-0xC0007ADF __clear_cache [/lib/ld.so.1] (40 bytes)
        0xC0013E70-0xC0013E8B __mp_newlist [/usr/lib/libmpatrol.so.1.0] (28 bytes)
        0xC0013E8C-0xC0013EB3 __mp_addhead [/usr/lib/libmpatrol.so.1.0] (40 bytes)
        0xC0013EB4-0xC0013EE7 __mp_addtail [/usr/lib/libmpatrol.so.1.0] (52 bytes)
        0xC0013EE8-0xC0013F1B __mp_prepend [/usr/lib/libmpatrol.so.1.0] (52 bytes)
        ...
        0xC001A0DC-0xC001A0FF __nw__FUi [/usr/lib/libmpatrol.so.1.0] (36 bytes)
        0xC001A100-0xC001A123 __arr_nw__FUi [/usr/lib/libmpatrol.so.1.0] (36 bytes)
        0xC001A124-0xC001A143 __dl__FPv [/usr/lib/libmpatrol.so.1.0] (32 bytes)
        0xC001A144-0xC001A163 __arr_dl__FPv [/usr/lib/libmpatrol.so.1.0] (32 bytes)
        0xC003BB14-0xC003BB45 __libc_global_ctors [/lib/libc.so.6] (50 bytes)
        0xC003BB48-0xC003BB97 __libc_init [/lib/libc.so.6] (80 bytes)
        0xC003BB98-0xC003BBC3 __libc_print_version [/lib/libc.so.6] (44 bytes)
        0xC003BBC4-0xC003BBD7 __libc_main [/lib/libc.so.6] (20 bytes)
        ...
        0xC008F8BC-0xC008FA4D __moddi3 [/lib/libc.so.6] (402 bytes)
        0xC008FA50-0xC008FB19 __udivdi3 [/lib/libc.so.6] (202 bytes)
        0xC008FB1C-0xC008FC1B __umoddi3 [/lib/libc.so.6] (256 bytes)
        0xC008FC1C-0xC008FC4D _fini [/lib/libc.so.6] (50 bytes)
    ----------------------------------------------------------------------------

    The next block of data shows a summary of all freed memory allocations.
    This is only possible because the NOFREE option was also given, otherwise
    there would be no details on freed memory allocations.  All of these entries
    show where the allocation was freed, which can be useful if you quickly
    needed to see where an allocation was freed.  The SHOWFREED option also
    displays this information.

    As this example was run on UNIX, the mpatrol library replaces the default
    implementations of malloc(), free(), etc.  As can be seen below, this allows
    the library to trace all calls to allocate dynamic memory in a process, even
    from functions that were not compiled with mpatrol.  The two functions shown
    below were called by the mpatrol library in order to read the symbols from
    ELF object files.  However, they are located in the ELF access library which
    was not compiled with mpatrol.

    Note that the following data has again been cut down in size for the
    purposes of this example.  The `...' marks text that has been removed.

    ----------------------------------------------------------------------------
    freed allocations: 9 (15740 bytes)
        0x8000A098 (126 bytes) {free:2:0} [-|-|-]
            0x800011BC elf_end
            0xC0019668 __mp_init
            0xC001982A __mp_alloc
            0x8000099C main
            0x80000944 _start

        0x8000A136 (3536 bytes) {free:3:0} [-|-|-]
            0x8000104E _elf_free
            0xC0019668 __mp_init
            0xC001982A __mp_alloc
            0x8000099C main
            0x80000944 _start

        ...
    ----------------------------------------------------------------------------

    The final block of data shows a summary of all unfreed memory allocations.
    This can show up memory leaks, although the first unfreed memory allocation
    in this example comes from the standard C library.  On systems such as UNIX
    it does not really matter about these unfreed allocations since they will
    automatically be returned to the system on process termination.

    However, the second unfreed allocation shows an example of a memory leak,
    where no pointers referencing that allocation remain in the program to free
    it with.  If this was within a loop then the program could quickly run away
    with memory, causing at least a decrease in performance, and at most a
    memory shortage.  The mpatrol library makes it easier to spot memory leaks.

    The SHOWUNFREED option also displays this information.

    ----------------------------------------------------------------------------
    unfreed allocations: 2 (108 bytes)
        0x8000A010 (104 bytes) {malloc:1:0} [-|-|-]
            0xC0052B4A _IO_fopen
            0xC0017A0C __mp_openlogfile
            0xC0019648 __mp_init
            0xC001982A __mp_alloc
            0x8000099C main
            0x80000944 _start

        0x8000AFC4 (4 bytes) {malloc:10:0} [main|test.c|14]
            0x8000099C main
            0x80000944 _start
    ----------------------------------------------------------------------------


Summary
=======

    Hopefully this has been an interesting guided tour of the capabilities of
    the mpatrol library, and has given you an understanding of what is involved
    in using it effectively.

    Obviously, I haven't covered every single feature of the library as that
    would require a document about five times this size, but I hope that it
    should be easy for you understand and use these other features now that you
    know how to use the ones I've just described.

    And always remember to do final release builds without the mpatrol library
    as the library is much slower than normal malloc implementations and uses
    much more memory.

    Happy debugging!
