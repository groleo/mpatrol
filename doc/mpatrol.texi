\input texinfo

@c mpatrol
@c A library for controlling and tracing dynamic memory allocations.
@c Copyright (C) 1997-1999 Graeme S. Roy <graeme@epc.co.uk>

@c $Id: mpatrol.texi,v 1.7 1999-11-18 20:04:12 graeme Exp $

@c %**start of header
@setfilename mpatrol.info
@settitle mpatrol
@setchapternewpage odd
@finalout
@c %**end of header

@dircategory Programming tools
@direntry
* mpatrol: (mpatrol).           The mpatrol library.
@end direntry

@c Remember to change these after each revision!
@set EDITION 1.1
@set VERSION 1.0.6
@set UPDATED 18th November, 1999

@ifhtml
@image{images/mpatrol}
@end ifhtml

@ifinfo
This file documents mpatrol, a library for controlling and tracing dynamic
memory allocations.

Copyright @copyright{} 1997-1999 Graeme S. Roy @email{graeme@@epc.co.uk}

This is edition @value{EDITION} of the mpatrol manual for version
@value{VERSION}, @value{UPDATED}.

Permission is granted to make and distribute verbatim copies of this manual
provided the copyright notice and this permission notice are preserved on all
copies.

@ignore
Permission is granted to process this file through TeX and print the results,
provided the printed document carries a copying permission notice identical to
this one except for the removal of this paragraph (this paragraph not being
relevant to the printed manual).
@end ignore

Permission is granted to copy and distribute modified versions of this manual
under the conditions for verbatim copying, provided that the entire resulting
derived work is distributed under the terms of a permission notice identical to
this one.

Permission is granted to copy and distribute translations of this manual into
another language, under the above conditions for modified versions, except that
this permission notice may be stated in a translation approved by the Free
Software Foundation.

All product names mentioned in the documentation and source code for this
library are the trademarks of their respective owners.
@end ifinfo

@titlepage
@title mpatrol
@subtitle A library for controlling and tracing dynamic memory allocations
@subtitle Edition @value{EDITION} for mpatrol version @value{VERSION}
@subtitle @value{UPDATED}
@sp 5
@image{images/mpatrol}
@author Graeme S. Roy
@page
@vskip 0pt plus 1filll
Copyright @copyright{} 1997-1999 Graeme S. Roy <@email{graeme@@epc.co.uk}>

Permission is granted to make and distribute verbatim copies of this manual
provided the copyright notice and this permission notice are preserved on all
copies.

Permission is granted to copy and distribute modified versions of this manual
under the conditions for verbatim copying, provided that the entire resulting
derived work is distributed under the terms of a permission notice identical to
this one.

Permission is granted to copy and distribute translations of this manual into
another language, under the above conditions for modified versions, except that
this permission notice may be stated in a translation approved by the Free
Software Foundation.

All product names mentioned in the documentation and source code for this
library are the trademarks of their respective owners.
@end titlepage

@contents

@node Top, Foreword, , (dir)
@top mpatrol

This document describes mpatrol, a library for controlling and tracing dynamic
memory allocations.

This is edition @value{EDITION} of the mpatrol manual for version
@value{VERSION}, @value{UPDATED}.

@menu
* Foreword::                    Motivation and feedback.
* Overview::                    Overview of mpatrol.
* Features::                    Features of mpatrol.
* Installation::                Building and installing.
* Memory allocations::          Background.
* Operating system support::    Additional background.
* Examples::                    Examples of usage.
* Functions::                   Library functions.
* Environment::                 Library run-time options.
* Options::                     Command line options.
* Supported systems::           Known platforms that mpatrol runs on.
* Notes::                       Known bugs and future enhancements.
* Related software::            Similar programs.
* Function index::              Library functions.
* Index::                       Main index.
@end menu

@node Foreword, Overview, Top, Top
@unnumbered Foreword
@cindex foreword

I first started writing this library a few years ago when the company I work for
sent me out to a customer who had reported a memory leak, which he expected was
coming from the code generated by our C++ compiler.  A few years on and the
library has changed dramatically from its first beginnings, but I thought I'd
release it publicly in case anyone else found it useful.

When writing the library, I placed more emphasis on the quantity and quality of
information about allocated memory rather than the speed and efficiency of
allocating the actual memory.  This means that the library will use dramatically
more memory than normal dynamic memory allocation libraries and can slow down to
a crawl depending on which options you use.  However, the end results are likely
to be accurate and reliable, and in most cases the library will run quite
happily at a sane speed.

@cindex warranty
The mpatrol library is by no means the only library of its kind.  Solaris 7 has
no less that 6 different malloc libraries, and there are plenty available as
freeware or as commercial products.  Try to keep in mind that mpatrol comes with
absolutely no warranty and so if it doesn't work for you and you need a fast
solution, try some of the other libraries or products available.  I have listed
some of the most popular at the end of this manual (@pxref{Related software}).

@cindex manual layout
This manual is arranged so that complete reference material on the mpatrol
library can be found in the appendices, while introductory and background
material can be found in the preceding chapters and sections.  For readers who
wish to delve right in and use the library, the Installation
(@pxref{Installation}) and Examples (@pxref{Examples}) chapters should be enough
to get started.  Otherwise, this manual should be read from beginning to end in
order to get the most out of the software it describes.

@cindex bug reports
@cindex reporting bugs
Due to their very nature, problems with dynamic memory allocations are
notoriously difficult to reproduce and debug, and this is likely to be the case
if you find a bug in the mpatrol library as it might be extremely hard to
reproduce on another system.  Details on how to report bugs are given elsewhere
in this document (@pxref{Notes}), but it would be very useful if you could try
to provide as much information as possible when reporting a problem, and that
includes having a look in the library source code to see if it's obvious what is
wrong.

@cindex contacting the author
@cindex author, contacting
@cindex getting updates
@cindex updates
The latest version of the mpatrol library and this manual can always be found at
@uref{http://www.cbmamiga.demon.co.uk/mpatrol/}, and any correspondence relating
to mpatrol (bug reports, enhancement requests, compliments, etc.) should be sent
to @email{mpatrol@@cbmamiga.demon.co.uk}.  I normally only check my e-mail about
once or twice a week, so don't expect an immediate response.  I can also be
reached at @email{graeme@@epc.co.uk} but that is my work e-mail address.

@cindex release builds
Oh, and always remember to do final release builds without the mpatrol library
as the library is much slower than normal malloc implementations and uses much
more memory.

Happy debugging!

Graeme Roy, 11th October, 1999.

Edinburgh, Scotland.

@node Overview, Features, Foreword, Top
@chapter Overview
@cindex overview

@cindex mpatrol
@cindex mpatrol library
@cindex library, mpatrol
@cindex run-time errors
@cindex errors, run-time
The mpatrol library is yet another link library that attempts to diagnose
run-time errors that are caused by the wrong use of dynamically allocated
memory.  If you don't know what the @code{malloc()} function or @code{operator
new[]} do then this library is probably not for you.  You have to have a certain
amount of programming expertise and a knowledge of how to run a command line
compiler and linker before you should attempt to use this.

Along with providing a comprehensive and configurable log of all dynamic memory
operations that occurred during the lifetime of a program, the mpatrol library
performs extensive checking to detect any misuse of dynamically allocated
memory.  All of this functionality can be integrated into existing code through
the inclusion of a single header file at compile-time.  On UNIX platforms this
may not even be necessary as the mpatrol library can be linked with existing
object files at link-time or, on some platforms, even dynamically linked with
existing programs at run-time.

All logging and tracing output from the mpatrol library is sent to a separate
log file in order to keep its diagnostics separate from any that the program
being tested might generate.  A wide variety of library settings can also be
changed at run-time via an environment variable, thus removing the need to
recompile or relink in order to change the library's behaviour.

@node Features, Installation, Overview, Top
@chapter Features
@cindex mpatrol features
@cindex features

An overall list of features contained in the mpatrol library is given below.
This is not intended to be exhaustive since the best way to see what the library
does is to read the documentation and try it out.

@itemize @bullet
@item
Written for UNIX, AmigaOS, Windows and Netware platforms.

@cindex archive library
@cindex library, archive
@cindex shared library
@cindex library, shared
@cindex thread-safe library
@cindex library, thread-safe
@item
Can be built as archive, shared and/or thread-safe libraries on systems that
support them, or even as one large object file.

@cindex best fit
@cindex allocation algorithm
@item
Details of memory allocations and free memory are stored internally as a tree
structure for speed and also to allow the best fit allocation algorithm to be
used.  This also enables the library to perform intelligent resizing of memory
allocations and can be used to quickly determine if an address has been
allocated on the heap.

@item
Contains 13 replacement C dynamic memory allocation functions:

@multitable @columnfractions .2 .1 .7
@item @code{malloc()}
@tab ANSI
@tab Allocates memory.
@item @code{calloc()}
@tab ANSI
@tab Allocates zero-filled memory.
@item @code{memalign()}
@tab UNIX
@tab Allocates memory with a specified alignment.
@item @code{valloc()}
@tab UNIX
@tab Allocates page-aligned memory.
@item @code{pvalloc()}
@tab UNIX
@tab Allocates a number of pages.
@item @code{strdup()}
@tab UNIX
@tab Duplicates a string.
@item @code{strndup()}
@tab old
@tab Duplicates a string with a maximum length.
@item @code{strsave()}
@tab old
@tab Duplicates a string.
@item @code{strnsave()}
@tab old
@tab Duplicates a string with a maximum length.
@item @code{realloc()}
@tab ANSI
@tab Resizes memory.
@item @code{recalloc()}
@tab old
@tab Resizes memory allocated by @code{calloc()}.
@item @code{free()}
@tab ANSI
@tab Frees memory.
@item @code{cfree()}
@tab old
@tab Frees memory allocated by @code{calloc()}.
@end multitable

@item
Contains 4 replacement C++ dynamic memory allocation functions:

@multitable @columnfractions .3 .7
@item @code{operator new}
@tab Allocates memory.
@item @code{operator new[]}
@tab Allocates memory for an array.
@item @code{operator delete}
@tab Frees memory.
@item @code{operator delete[]}
@tab Frees memory allocated by @code{operator new[]}.
@end multitable

@item
Contains support for a user-defined low-memory handler function, including a
replacement for the C++ function, @code{set_new_handler()}.

@item
Contains support for user-defined prologue and epilogue callback functions,
which get called before and after every memory allocation, reallocation or
deallocation.

@item
A function is provided to return as much information as possible about a given
memory allocation, and can be called at any time during program execution.

@item
A function is provided to display library settings and heap usage statistics,
including peak memory usage.  This information is also displayed at program
termination.

@item
The library reads any user-controllable options at run-time from an environment
variable, but this does not have to be set as defaults will then be used.  This
prevents having to recompile anything in order to change any library settings.
An option exists to display a quick-reference summary of all of the recognised
options to the standard error file stream.

@item
All diagnostics and logging are sent to a file in the current directory, but
this can be overridden, including forcing the log file to be the standard output
or standard error file streams.

@item
Options exist to log details of every memory allocation, reallocation or
deallocation when they occur.

@cindex trap signal
@cindex signal, trap
@item
Options exist to halt the program at a specific memory allocation, reallocation
or deallocation on systems that support the trap signal.  This can be extremely
useful when running the program under a debugger.

@item
On UNIX platforms, the @code{mmap()} function can optionally be used to allocate
memory instead of the @code{sbrk()} function, but only if the system supports
it.  This can be useful if the mpatrol library clashes with another malloc
library that uses @code{sbrk()} to allocate heap memory.

@item
All newly-allocated memory that is not allocated by the @code{calloc()} or
@code{recalloc()} functions will be pre-filled with a non-zero value in order to
catch out programs that wrongly assume that all newly-allocated memory is
zeroed.  This value can be modified at run-time.

@item
Can automatically check to see if there have been any illegal writes to bytes
located just before and after every memory allocation through the use of
overflow buffers.  The size of such overflow buffers and the value to pre-fill
them with can be modified at run-time.  The checks will be performed before
every memory allocation call to ensure that nothing has overwritten the
overflow buffers, but a function is also provided to perform additional checks
under the programmer's control and an option exists to specify a range in which
checks will be performed.

@item
On systems that support them, watch point areas can be used instead of overflow
buffers so that every read and write to memory is checked to ensure that it is
not within an overflow buffer.

@item
Can automatically check to see if there have been any illegal writes to free
memory blocks.  The value to pre-fill free memory blocks with can be modified
at run-time.  The check will be performed before every memory allocation call
to ensure that nothing has overwritten the free memory block, but a function is
also provided to perform additional checks under the programmer's control and
an option exists to specify a range in which checks will be performed.

@item
On systems that support memory protection, every memory allocation can
optionally be allocated at least one page of memory.  That way, any free memory
blocks can be made read and write protected so that nothing can access free
memory on the heap.  An option is provided to specify whether all memory
allocations should be allocated at the start or at the end of such pages, and
the bytes left over within the pages become overflow buffers.

@item
All freed memory allocations can optionally be prevented from being returned to
the free memory pool.  This is useful for detecting if use is being made of
freed memory just after a memory allocation has been freed.  The contents of
the memory allocation can either be preserved or can be pre-filled with a value
in order to detect illegal writes to the freed memory allocation.

@item
The internal data structures used by the library are kept separate from the
rest of the memory allocations.  On systems that support memory protection, all
of these internal data structures will be write-protected in order to prevent
corruption by the calling program.  This feature can be overridden at run-time
as it can slow the program down.

@cindex signals
@item
Signals are always saved and restored on entry to each library function and
@code{errno} is set to @code{ENOMEM} if memory cannot be allocated.

@item
On systems that support memory protection, the library attempts to detect any
illegal memory accesses and display as much information as it can obtain about
the address in question and where the illegal memory access occurred.

@item
A call stack traceback from any function performing a memory allocation is
stored if the library supports this feature on the system it is being run on.
This information can then be displayed when information about a specific memory
allocation is required.  Two different call stack traceback implementations are
provided.

@item
Symbol table details from executable files and shared libraries are
automatically read on systems that support this feature in order to make the
call stack tracebacks more meaningful.  An option also exists to display a
complete list of the symbols that were read by the library at program
termination.

@item
If the library is unable to automatically determine a program's executable
filename to read symbols from then an option exists to specify the full path to
the program's executable file.

@item
An option exists to change the default alignment used for general-purpose memory
allocations.

@item
Contains support for a user-defined limit to available memory which can be
useful for stress-testing a program in simulated low memory conditions.

@item
An option exists to display a complete memory map of the heap at program
termination.  A function to do this is also available to call at any point
during program execution.

@item
Options exist to display all freed and unfreed memory allocations at program
termination in order to detect memory leaks.

@item
An option exists to abort the program with a failure condition if there are more
than a specified number of unfreed memory allocations at program termination.
This could be useful for batch testing in order to check that all tests free up
most of their allocated memory.

@item
Functions always report if their arguments are illegal in order to pinpoint any
errors, and options exist to perform rigorous checking of arguments when
allocating, reallocating and freeing memory.  In addition, checking is performed
to ensure that memory allocated by @code{operator new[]} is not freed with
@code{free()} for example.

@item
The type of function performing a memory allocation is always stored along with
the allocation, as well as the file and line number it was called from.  If
compiled with @command{gcc}, the function name will also be stored and the
thread identifier will be stored if using the thread-safe library.

@item
The library uses a header file to redefine the memory allocation functions as
macros in order to obtain more information about where they were called from.
This is not strictly required on UNIX platforms, since the library automatically
redefines the default system memory allocation functions.

@item
A shell script is supplied for UNIX platforms to run a program that was linked
with the mpatrol library with any specified options on the command line.  On
some UNIX platforms, an option also exists to override the default memory
allocation routines for any dynamically-linked program that was not previously
linked with the mpatrol library.

@cindex test suite
@item
A small test suite is provided in order to test basic features.

@item
User documentation is currently available in @TeX{}info format as well as UNIX
manual pages.
@end itemize

@node Installation, Memory allocations, Features, Top
@chapter Installation
@cindex installation
@cindex building the library
@cindex library, building

@cindex Amiga 4000/040
The mpatrol library was initially developed on an Amiga 4000/040 running AmigaOS
3.1.  I then installed Redhat Linux 5.1 on my Amiga and added support for
Linux/m68k.  I've tried my best to make it as easy as possible to build and
install mpatrol on any system, but it isn't likely to run smoothly for
everybody.  However, there shouldn't be any major problems if you perform the
following steps.

@enumerate 1
@item
Go into the @file{build} directory and then into the appropriate subdirectory
for your system.

@cindex Makefile
@cindex CC
@cindex AR
@cindex LD
@cindex CFLAGS
@cindex OFLAGS
@cindex SFLAGS
@cindex TFLAGS
@cindex compiling
@cindex compiler
@cindex linking
@cindex linker
@cindex optimisation
@item
Edit the @file{Makefile} in that directory and check that it is using the
appropriate compiler and build tools.  The @code{CC} macro specifies the
compiler, the @code{AR} macro specifies the tool used to build the archive
library and the @code{LD} macro specifies the tool to build the shared library.
The @code{CFLAGS} macro specifies compiler options that are always to be used,
the @code{OFLAGS} macro specifies optimisation options for the compiler, the
@code{SFLAGS} macro specifies options to be passed to the compiler when building
a shared library and the @code{TFLAGS} macro specifies options to be passed to
the compiler when building a thread-safe library.  You may also need to change
the library names and library build commands on different systems.

@cindex make
@cindex all (make target)
@cindex clean (make target)
@cindex clobber (make target)
@item
Use the @command{make} command (or equivalent) to build the mpatrol library in
archive form.  The @samp{all} target builds all possible combinations of the
mpatrol library for your system.  The @samp{clean} target removes all relevant
object files from the current directory, while the @samp{clobber} target also
removes all libraries that have been built from the current directory.

@cindex symbolic links
@cindex links, symbolic
@item
Copy all of the libraries that have been built into your local library
directory.  If there were symbolic links created in the @file{build} directory
then these should be recreated in the local library directory rather than simply
copying them.

@item
Go up two directory levels into the @file{src} directory and copy the
@file{mpatrol.h} header file into your local include directory.

@item
On UNIX platforms, go up one directory level into the @file{bin} directory and
copy the @file{mpatrol} shell script into your local bin directory.

@cindex manual pages
@item
On UNIX platforms, go up one directory level into the @file{man} directory and
copy the @file{man1} and @file{man3} subdirectories to your local man directory.
Unfortunately, the location for manual pages varies from system to system so you
may or may not also be able to copy the @file{cat1} and @file{cat3}
subdirectories as well.  The @file{man*} subdirectories contain the unformatted
manual pages while the @file{cat*} subdirectories contain the formatted manual
pages.

@cindex @TeX{}info
@cindex documentation
@cindex printing
@item
Go up one directory level into the @file{doc} directory and examine the files
located there.  The @file{mpatrol.texi} file contains the @TeX{}info source for
this manual and can be translated into a wide variety of documentation formats.
There may already be translated files in the @file{doc} directory, but if not
you will have to generate them yourself using an appropriate tool and then
install or print them.
@end enumerate

@node Memory allocations, Operating system support, Installation, Top
@chapter Memory allocations
@cindex memory allocations

@cindex C
@cindex C++
@cindex Pascal
@cindex BASIC
@cindex FORTRAN
In the C and C++ programming languages there are generally three different types
of memory allocation that can be used to hold the contents of variables.  Other
programming languages such as Pascal, BASIC and FORTRAN also support some of
these types of allocation, although their implementations may be slightly
different.

@menu
* Static memory allocations::   Fixed location, fixed size.
* Stack memory allocations::    Variable location, fixed size.
* Dynamic memory allocations::  Variable location, variable size.
@end menu

@node Static memory allocations, Stack memory allocations, , Memory allocations
@section Static memory allocations
@cindex static memory allocations
@cindex memory allocations, static

@cindex file scope variables
@cindex variables, file scope
@cindex local static variables
@cindex variables, local static
The first type of memory allocation is known as a @emph{static memory
allocation}, which corresponds to file scope variables and local static
variables.  The addresses and sizes of these allocations are fixed at the time
of compilation@footnote{Or more accurately, at link time.} and so they can be
placed in a fixed-sized data area which then corresponds to a section within the
final linked executable file.  Such memory allocations are called static because
they do not vary in location or size during the lifetime of the program.

@cindex data sections
@cindex sections
@cindex BSS
There can be many types of data sections within an executable file; the three
most common are normal data, BSS data and read-only data.  BSS data contains
variables and arrays which are to be initialised to zero at run-time and so is
treated as a special case, since the actual contents of the section need not be
stored in the executable file.  Read-only data consists of constant variables
and arrays whose contents are guaranteed not to change when a program is being
run.  For example, on a typical SVR4 UNIX system the following variable
definitions would result in them being placed in the following sections:

@smallexample
int a;           /* BSS data */
int b = 1;       /* normal data */
const int c = 2; /* read-only data */
@end smallexample

@cindex tentative declarations
@cindex declarations, tentative
@cindex common variables
In C the first example would be considered a @emph{tentative} declaration, and
if there was no subsequent definition of that variable in the current
translation unit then it would become a @emph{common} variable in the resulting
object file.  When the object file gets linked with other object files, any
common variables with the same name become one variable, or take their
definition from a non-tentative definition of that variable.  In the former
case, the variable is placed in the BSS section.  Note that C++ has no support
for tentative declarations.

As all static memory allocations have sizes and address offsets that are known
at compile-time and are explicitly initialised, there is very little that can go
wrong with them.  Data can be read or written past the end of such variables,
but that is a common problem with all memory allocations and is generally easy
to locate in that case.  On systems that separate read-only data from normal
data, writing to a read-only variable can be quickly diagnosed at run-time.

@node Stack memory allocations, Dynamic memory allocations, Static memory allocations, Memory allocations
@section Stack memory allocations
@cindex stack memory allocations
@cindex memory allocations, stack

@cindex parameter variables
@cindex variables, parameter
@cindex call-by-value
@cindex non-static local variables
@cindex variables, non-static local
The second type of memory allocation is known as a @emph{stack memory
allocation}, which corresponds to non-static local variables and call-by-value
parameter variables.  The sizes of these allocations are fixed at the time of
compilation but their addresses will vary depending on when the function which
defines them is called.  Their contents are not immediately initialised, and
must be explicitly initialised by the programmer upon entry to the function or
when they become visible in scope.

@cindex stack
@cindex registers
Such memory allocations are placed in a system memory area called the
@emph{stack}, which is allocated per process@footnote{Or per thread on some
systems.} and generally grows down in memory.  When a function is called, the
state of the calling function must be preserved so that when the called function
returns, the calling function can resume execution.  That state is stored on the
stack, including all local variables and parameters.  The compiler generates
code to increase the size of the stack upon entry to a function, and decrease
the size of the stack upon exit from a function, as well as saving and restoring
the values of registers.

There are a few common problems using stack memory allocations, and most
generally involve uninitialised variables, which a good compiler can usually
diagnose at compile-time.  Some compilers also have options to initialise all
local variables with a bit pattern so that uninitialised stack variables will
cause program faults at run-time.  As with static memory allocations, there can
be problems with reading or writing past the end of stack variables, but as
their sizes are fixed these can usually easily be located.

@node Dynamic memory allocations, , Stack memory allocations, Memory allocations
@section Dynamic memory allocations
@cindex dynamic memory allocations
@cindex memory allocations, dynamic

The last type of memory allocation is known as a @emph{dynamic memory
allocation}, which corresponds to memory allocated via @code{malloc()} or
@code{operator new[]}.  The sizes, addresses and contents of such memory vary
at run-time and so can cause a lot of problems when trying to diagnose a fault
in a program.  These memory allocations are called dynamic memory allocations
because their location and size can vary throughout the lifetime of a program.

@cindex heap
@cindex garbage collector
@cindex ML
Such memory allocations are placed in a system memory area called the
@emph{heap}, which is allocated per process on some systems, but on others may
be allocated directly from the system in scattered blocks.  Unlike memory
allocated on the stack, memory allocated on the heap is not freed when a
function or scope is exited and so must be explicitly freed by the programmer.
The pattern of allocations and deallocations is not guaranteed to be (and is not
really expected to be) linear and so the functions that allocate memory from the
heap must be able to efficiently reuse freed memory and resize existing
allocated memory on request.  In some programming languages there is support for
a @emph{garbage collector}, which attempts to automatically free memory that has
had all references to it removed, but this has traditionally not been very
popular for programming languages such as C and C++, and has been more widely
used in functional languages like ML@footnote{There is currently at least one
garbage collection package available for C and C++ (@pxref{Related software}).}.

Because dynamic memory allocations are performed at run-time rather than
compile-time, they are outwith the domain of the compiler and must be
implemented in a run-time package, usually as a set of functions within a
linker library.  Such a package manages the heap in such a way as to abstract
its underlying structure from the programmer, providing a common interface to
heap management on different systems.  However, this @emph{malloc library} must
decide whether to implement a fast memory allocator, a space-conserving memory
allocator, or a bit of both.  It must also try to keep its own internal tables
to a minimum so as to conserve memory, but this means that it has very little
capability to diagnose errors if any occur.

@cindex alloca
@cindex variable length arrays
In some compiler implementations there is a builtin function called
@code{alloca()}.  This is a dynamic memory allocation function that allocates
memory from the stack rather than the heap, and so the memory is automatically
freed when the function that called it returns.  This is a non-standard feature
that is not guaranteed to be present in a compiler, and indeed may not be
possible to implement on some systems.  However, some compilers now support
variable length arrays which provide roughly the same functionality.

As can be seen from the above paragraphs, dynamic memory allocations are the
types of memory allocations that can cause the most problems in a program since
almost nothing about them can be used by the compiler to give the programmer
useful warnings about using uninitialised variables, using freed memory, running
off the end of a dynamically-allocated array, etc.  It is these types of memory
allocation problems that the mpatrol library loves to get its teeth into!

@node Operating system support, Examples, Memory allocations, Top
@chapter Operating system support
@cindex operating systems

@cindex memory management interface
@cindex embedded systems
@cindex systems, embedded
Beneath every malloc library's public interface there is the underlying
operating system's memory management interface.  This provides features which
can be as simple as giving processes the ability to allocate a new block of
memory for themselves, or it can offer advanced features such as protecting
areas of memory from being read or written.  Some embedded systems have no
operating systems and hence no support for dynamic memory allocation, and so the
malloc library must instead allocate blocks of memory from a fixed-sized array.
The mpatrol library can be built to support all of the above types of system,
but the more features an operating system can provide it with, the more it can
do.

@cindex address space
On operating systems such as UNIX and Windows, all dynamic memory allocation
requests from a process are dealt with by using a feature called @emph{virtual
memory}.  This means that a process cannot perform illegal requests without
them being denied, which protects the other running processes and the operating
system from being affected by such errors.  However, on AmigaOS and Netware
platforms there is no virtual memory support and so all processes effectively
share the same address space as the operating system and any other running
processes.  This means that one process can accidentally write into the data
structures of another process, usually causing the other process to fail and
bring down the system.  In addition, a process which allocates a lot of memory
will result in there being less available memory for other running processes,
and in extreme cases the operating system itself.

@menu
* Virtual memory::                  Addition facilities.
* Call stacks and symbol tables::   Tracing information.
@end menu

@node Virtual memory, Call stacks and symbol tables, , Operating system support
@section Virtual memory
@cindex virtual memory
@cindex memory, virtual

@cindex physical memory
@cindex memory, physical
@emph{Virtual memory} is an operating system feature that was originally used to
provide large usable address spaces for every process on machines that had very
little physical memory.  It is used by an operating system to
fool@footnote{Well, perhaps that's too harsh a word, but it will certainly seem
that way to a process running on a 32-bit UNIX system with only 4 megabytes of
physical memory, and yet it will be able to read from and write to over 4
gigabytes of virtual memory!} a running process into believing that it can
allocate a vast amount of memory for its own purposes, although whether it is
allowed to or not depends on the operating system and the permissions of the
individual user.

@cindex virtual address
@cindex address, virtual
@cindex physical address
@cindex address, physical
@cindex memory management unit
@cindex MMU
@cindex system page size
@cindex page size
@cindex page
Virtual memory works by translating a virtual address (which the process uses)
into a physical address (which the operating system uses).  It is generally
implemented via a piece of hardware called a @emph{memory management unit}, or
MMU.  The MMU's primary job is to translate any virtual addresses that are
referred to by machine instructions into physical addresses by looking up a
table which is built by the operating system.  This table contains mappings to
and from @emph{pages}@footnote{The size of a page varies between operating
systems and processor architectures, but they are generally around 4 or 8
kilobytes in size, and are always a power of two.} rather than bytes since it
would otherwise be very inefficient to handle mappings between individual bytes.
As a result, every virtual memory operation operates on pages, which are
indivisible and are always aligned to the system page size.

@cindex swapping
@cindex swap file
@cindex swap in
@cindex swap out
Even though each process can now see a huge address space, what happens when it
attempts to allocate more pages than actually physically exist, or allocate an
additional page of memory when all of the physical pages are in use by it and
other processes?  This problem is solved by the operating system temporarily
saving one or more of the least-used pages (which might not necessarily belong
that that process) to a special place in the file system called a @emph{swap
file}, and mapping the new pages to the physical addresses where the old pages
once resided.  The old pages which have been @emph{swapped out} are no longer
currently accessible, but their location in the swap file is noted in the
translation table.

@cindex page fault
@cindex fault, page
@cindex thrashing
However, if one of the pages that has been swapped out is accessed again, a
@emph{page fault} occurs at the instruction which referred to the address and
the operating system catches this and reloads the page from the swap file,
possibly having to swap out another page to make space for the new one.  If this
occurs too often then the operating system can slow down, having to constantly
swap in and swap out the same pages over and over again.  Such a problem is
called @emph{thrashing} and can only really be overcome by using less virtual
memory or buying more physical memory.

@cindex memory mapped files
@cindex mapping files
@cindex files, mapping
It is also possible to take advantage of the virtual memory system's
interaction between physical memory and the file system in program code, since
mapping an existing file to memory means that the usual file I/O operations can
be replaced with memory read and write operations.  The operating system will
work out the optimum way to read and write any buffers and it means that only
one copy of the file exists in both physical memory and the file system.  Note
that this is how @emph{shared libraries}@footnote{DLLs on Windows platforms.}
on UNIX platforms are generally implemented, with each individual process that
uses the shared library having it mapped to somewhere in its address space.

@cindex memory protection
@cindex read protection
@cindex write protection
Another major feature of virtual memory is its ability to read protect and write
protect individual pages of process memory.  This means that the operating
system can control access to different parts of the address space for each
process, and also means that a process can read and/or write protect an area of
memory when it wants to ensure that it won't ever read or write to it again.  If
an illegal memory access is detected then a @emph{signal} will be sent to the
process, which can either be caught and handled or will otherwise terminate the
process.  Note that as with all virtual memory operations, this ability to
protect memory only applies to pages, so that it is not possible to protect
individual bytes.

@cindex watch points
However, some versions of UNIX have programmable software @emph{watch points}
which are implemented at operating system level.  These are normally used by
debuggers to watch a specified area of memory that is expected to be read from
or written to, but can just as easily be used to implement memory protection at
byte level.  Unfortunately, as this feature is implemented in
software@footnote{The operating system is still considered software.} rather
than in hardware, watch points tend to be incredibly slow, mainly as a result of
the operating system having to check every instruction before it is executed.

An operating system with virtual memory is usually going to run ever so slightly
slower than an operating system without it@footnote{Due to the overhead of
having to translate every address and swap in and out pages --- although memory
mapped files will usually be more efficient than using normal file operations on
a system without virtual memory.}, but the advantages of virtual memory far
outweigh the disadvantages, especially when used for debugging purposes.

@node Call stacks and symbol tables, , Virtual memory, Operating system support
@section Call stacks and symbol tables
@cindex function call stacks
@cindex call stacks
@cindex symbol tables
@cindex symbols

@cindex calling convention
@cindex application binary interface
@cindex ABI
As stated in the section on stack memory allocations (@pxref{Stack memory
allocations}), when a function is called, a copy of the caller's state
information (including local variables and registers) is saved on the stack so
that it can be restored when the called function returns.  On many operating
systems there is a @emph{calling convention}@footnote{Usually part of the
@emph{Application Binary Interface}, or ABI.} which defines the layout of such
stack entries so that code compiled in different languages and with different
compilers can be intermixed.  This usually specifies at which stack offsets the
stack pointer, program counter and local variables for the calling function can
be found, although on some processor architectures the function calling
conventions are specified by the hardware and so the operating system must use
these instead.

@cindex stack tracebacks
@cindex tracebacks
On systems that have consistent calling conventions, it is usually possible to
perform call stack @emph{tracebacks} from within the current function in order
to determine the stack of function calls that led to the current function.  This
is extremely useful for debugging purposes and is done by examining the current
stack frame to see if there is a pointer to the previous stack frame.  If there
is, then it can be followed to find out all of the state information about the
calling function.  This can be repeated until there are no more stack frames.
This is generally how this information is determined by debuggers when a call
stack traceback is requested.

@cindex program counter
@cindex return address
In addition to the pointer to the previous stack frame, the saved state
information also always contains the saved program counter register, which
contains either the address of the instruction that performed the function call,
or the address of the instruction at which to continue execution when the
called function returns@footnote{Also known as the @emph{return address}.}.
This information can be used to identify which function performed the call,
since the address of the instruction must lie between the start and end of one
of the functions in the process.

@cindex object files
@cindex executable files
However, in order to determine this symbolic information, it must be possible to
find out where the start and end addresses of all of the functions in the
process are.  This can usually only be read from object files, since they
contain the symbol tables that were used by the linker to generate the final
executable file for the program@footnote{This information can also be determined
from compiler-generated debugging information, but that is another
story@dots{}}.  The object file's symbol tables normally contain information
about the start address, size, name and visibility of every symbol that was
defined, but this depends on the format of the object file and if the symbol
tables have been stripped from the final executable file.

@cindex dynamic linking
@cindex dynamic linker
@cindex shared libraries
@cindex dynamic link libraries
@cindex DLLs
On systems that support shared libraries, additional work must be done to
determine the symbolic information for all of the functions which have been
defined in them.  The symbols for functions that are defined in shared libraries
normally appear as undefined symbols in the executable file for the program and
so must be searched in the system in order to get the necessary information.  It
is usually necessary to liaise with the @emph{dynamic linker}@footnote{Which is
the part of the operating system that performs the run-time linking of shared
libraries.} on many systems.

@node Examples, Functions, Operating system support, Top
@chapter Examples
@cindex examples
@cindex tutorial

Following are a set of examples that are intended to illustrate what exactly is
possible with the mpatrol library and how to go about using it effectively.

You should already have built and installed the library and should know how to
link programs with the library.  Unfortunately, it isn't possible to give
specific instructions on how to do this as it varies from system to system and
also depends on your preferred compiler and development tools.

@cindex SVR4
However, on a typical SVR4 UNIX system, with mpatrol installed in
@file{/usr/local}, the mpatrol library can usually be incorporated into a
program using the following commands:

@itemize @bullet
@cindex COFF
@item
If the mpatrol library was built with no support for any object file format or
was built with support for the COFF object file format:

@smallexample
cc -I/usr/local/include <file> -L/usr/local/lib -lmpatrol
@end smallexample

@cindex ELF32
@item
If the mpatrol library was built with support for the ELF32 object file format
access library:

@smallexample
cc -I/usr/local/include <file> -L/usr/local/lib -lmpatrol -lelf
@end smallexample

@cindex BFD
@item
If the mpatrol library was built with support for the GNU BFD object file format
access library:

@smallexample
cc -I/usr/local/include <file> -L/usr/local/lib -lmpatrol -lbfd
   -liberty
@end smallexample
@end itemize

You should also know how to set an environment variable on your specific system.
Again, this varies from system to system and also depends on the command line
interpreter or shell that you use.  The environment variable that the mpatrol
library uses is called @env{MPATROL_OPTIONS}.  You can see exactly what options
are available for this environment variable by setting it to @option{HELP} and
then running a program that has been linked with the library.

@menu
* Example 1::                   Getting started.
* Example 2::                   Detecting incorrect reuse of freed memory.
* Example 3::                   Detecting use of free memory.
* Example 4::                   Using overflow buffers.
* Example 5::                   Incompatible function calls.
* Example 6::                   Additional useful information.
@end menu

@node Example 1, Example 2, , Examples
@section Getting started

@cindex crash
The first example we'll look at is when the argument in a call to @code{free()}
doesn't match the return value from @code{malloc()}, even though the intention
is to free the memory that was allocated by @code{malloc()}.  This example is in
@file{tests/fail/test1.c} and causes many existing @code{malloc()}
implementations to crash.

Along the way, I'll try to describe as many features of the mpatrol library as
possible, and illustrate them with examples.  Note that the output from your
version of the library is likely to vary slightly from that shown in the
examples, especially on non-UNIX systems.

@smallexample
23  /*
24   * Allocates a block of 16 bytes and then attempts to free the
25   * memory returned at an offset of 1 byte into the block.
26   */


29  #include "mpatrol.h"


32  int main(void)
33  @{
34      char *p;

36      if (p = (char *) malloc(16))
37          free(p + 1);
38      return EXIT_SUCCESS;
39  @}
@end smallexample

Note that I've removed the copyright message from the start of the file and
added line numbers so that the tracing below makes more sense.

@cindex mpatrol.log
@cindex log file
After compiling and linking the above program with the mpatrol library, the
@env{MPATROL_OPTIONS} environment variable should be set to be @option{LOGALL}
and the program should be executed, generating the following output in
@file{mpatrol.log}.

@smallexample
@@(#) mpatrol 1.0.4 (99/10/21)
Copyright (C) 1997-1999 Graeme S. Roy

This is free software, and you are welcome to redistribute it under
certain conditions; see the GNU Library General Public License for
details.

ALLOC: malloc (13, 16 bytes, 8 bytes) [main|test1.c|36]
        0x00010AE0 main
        0x000109D4 _start

returns 0x00028000

FREE: free (0x00028001) [main|test1.c|37]
        0x00010B24 main
        0x000109D4 _start

ERROR: free: 0x00028001 does not match allocation of 0x00028000
    0x00028000 (16 bytes) @{malloc:13:0@} [main|test1.c|36]
        0x00010AE0 main
        0x000109D4 _start

system page size:  8192 bytes
default alignment: 8 bytes
overflow size:     0 bytes
overflow byte:     0xAA
allocation byte:   0xFF
free byte:         0x55
allocation stop:   0
reallocation stop: 0
free stop:         0
unfreed abort:     0
lower check range: -
upper check range: -
prologue function: <unset>
epilogue function: <unset>
handler function:  <unset>
log file:          mpatrol.log
program filename:  /proc/729/object/a.out
symbols read:      3240
allocation count:  13
allocation peak:   4720 bytes
allocation limit:  0 bytes
allocated blocks:  1 (16 bytes)
freed blocks:      0 (0 bytes)
free blocks:       1 (8176 bytes)
internal blocks:   25 (204800 bytes)
total heap usage:  212992 bytes
total warnings:    0
total errors:      1
@end smallexample

Ignoring the copyright blurb at the top, let's first take a look at the initial
log message from the library.  I've annotated each of the items with a number
that corresponds to the descriptions below.

@smallexample
 (1)    (2)   (3)    (4)       (5)     (6)    (7)  (8)
  |      |     |      |         |       |      |    |
  V      V     V      V         V       V      V    V
ALLOC: malloc (13, 16 bytes, 8 bytes) [main|test1.c|36]
 (9) -> 0x00010AE0 main
        0x000109D4 _start <- (10)

returns 0x00028000 <- (11)
@end smallexample

@enumerate 1
@cindex allocation type
@cindex type of allocation
@item
Allocation type.  This generalises the type of dynamic memory operation that is
being performed, and can be one of @samp{ALLOC}, @samp{REALLOC} or @samp{FREE}.
This should make looking for all allocations, reallocations or frees in the log
file a lot easier.

@item
Allocation function.  This is the name of the function that has been called to
allocate the memory, in this case @samp{malloc}.

@cindex allocation index
@item
Allocation index.  This is incremented every time a new memory allocation is
requested, and persists even if the memory allocation is resized with
@code{realloc()} or @code{recalloc()}, so can be useful to keep track of a
memory allocation, even if its start address changes.  The mpatrol library may
use up the first few allocation indices when it gets initialised.

@item
Size of requested allocation.

@item
Alignment for requested allocation.  This is normally the default system
alignment for general-purpose memory allocations, but may be different depending
on the type of function that is used to allocate the memory.
@end enumerate

The following information contains source file details of where the call to
@code{malloc()} came from, but is only available if the source file containing
the call to @code{malloc()} included @file{mpatrol.h}; otherwise the fields will
all be @samp{-}.  Note that calls to the C++ operators currently do not contain
this information since they cannot be rewritten as preprocessor macros.

@enumerate 6
@cindex gcc
@cindex g++
@item
Function where call to @code{malloc()} took place.  This information is only
available if the source file containing the call to @code{malloc()} was compiled
with @command{gcc} or @command{g++}.

@item
Filename in which call to @code{malloc()} took place.

@item
Line number at which call to @code{malloc()} took place.
@end enumerate

@cindex entry-point
The following information contains function call stack details of where the
call to @code{malloc()} came from, but is only available if the mpatrol library
has been built on a platform that supports this.  The top-most entry should be
the function which called @code{malloc()} and the bottom-most entry should be
the entry-point for the process.

@enumerate 9
@item
Address of function call.  This is normally the address of the machine
instruction immediately after the function call instruction, also known as the
return address.

@cindex C++ mangled names
@cindex mangled names
@cindex demangler
@item
Function where call took place.  This information is only available if the
mpatrol library has been built on a platform that supports reading symbol table
information from executable files, and then only if there is an entry in the
symbol table corresponding to the return address.  C++ function names may still
be in their mangled form, but this can be easily rectified by processing the
log file with a C++ name demangler.
@end enumerate

The following information is only available when the allocation type is
@samp{ALLOC} or @samp{REALLOC} since it makes no sense when applied to
@samp{FREE}.

@enumerate 11
@item
The address of the new memory block that has been allocated by @code{malloc()}.
@end enumerate

As you can see, there is quite a lot of information that can be displayed from
a simple call to @code{malloc()}, and hopefully this information has been
presented in a clear and concise format in the log file.

The next entries in the log file correspond to the call to @code{free()}, which
attempts to free the memory allocated by @code{malloc()}, but supplies the wrong
address.

The first three lines should be self-explanatory as they are very similar to
those described above for @code{malloc()}.  However, the next lines signal that
a terminal error has occurred in the program, so I've annotated them as before.

@smallexample
FREE: free (0x00028001) [main|test1.c|37]
        0x00010B24 main
        0x000109D4 _start

 (1)   (2)
  |     |
  V     V
ERROR: free: 0x00028001 does not match allocation of 0x00028000
       (3)        (4)       (5)  (6)(7)  (8)    (9)  (10)
        |          |         |    |  |    |      |    |
        V          V         V    V  V    V      V    V
    0x00028000 (16 bytes) @{malloc:13:0@} [main|test1.c|36]
(11) -> 0x00010AE0 main
        0x000109D4 _start
@end smallexample

@enumerate 1
@cindex error severity
@cindex severity of errors
@cindex recoverable errors
@cindex fatal errors
@item
Error severity.  The mpatrol library has two different severities of error:
@samp{WARNING} and @samp{ERROR}.  The first is always recoverable, and serves
only to indicate that something is not quite right, and so may be useful in
determining where something started to go wrong.  The second may or may not be
recoverable, and the library terminates the program if it is fatal, displaying
any relevant information as it does this.

@item
Allocation function.  This is the name of the function used to allocate,
reallocate or free memory where the error was detected.  This may be omitted if
an error is detected elsewhere in the library.
@end enumerate

The following information is related to the information that the library has
stored about the relevant memory allocation.  This information is always
displayed in this format when details of individual memory allocations are
required.  If any information is missing then it simply means that the library
was not able to determine it when the memory block was first allocated.

@enumerate 3
@item
Address of memory allocation.

@item
Size of memory allocation.

@item
Allocation function.  This is the name of the function that was called to
allocate the memory block, in this case @samp{malloc}.  If the memory allocation
has been resized then this will be either @samp{realloc} or @samp{recalloc}.

@item
Allocation index.

@item
Reallocation index.  This is used to count the number of times a memory
allocation has been resized with @code{realloc()} or @code{recalloc()}.

@item
Function where original call to @code{malloc()} took place.  If the memory
allocation has been resized then this will be the name of the function which
last called @code{realloc()} or @code{recalloc()}.

@item
Filename in which original call to @code{malloc()} took place.  If the memory
allocation has been resized then this will be the filename in which the last
call to @code{realloc()} or @code{recalloc()} took place.

@item
Line number at which original call to @code{malloc()} took place.  If the memory
allocation has been resized then this will be the line number at which the last
call to @code{realloc()} or @code{recalloc()} took place.

@item
Function call stack of original memory allocation.  If the memory allocation has
been resized then this will be the call stack of the last call to
@code{realloc()} or @code{recalloc()}.
@end enumerate

So, the mpatrol library detected the error in the above program and terminated
it.  When the library terminates it always displays a summary of various memory
allocation statistics and settings that were used during the execution of the
program.

@cindex library settings
@cindex settings
@cindex library statistics
@cindex statistics
The various settings and statistics displayed by the library for the above
example have been numbered and their descriptions appear below.

@smallexample
 1  system page size:  8192 bytes
 2  default alignment: 8 bytes
 3  overflow size:     0 bytes
 4  overflow byte:     0xAA
 5  allocation byte:   0xFF
 6  free byte:         0x55
 7  allocation stop:   0
 8  reallocation stop: 0
 9  free stop:         0
10  unfreed abort:     0
11  lower check range: -
12  upper check range: -
13  prologue function: <unset>
14  epilogue function: <unset>
15  handler function:  <unset>
16  log file:          mpatrol.log
17  program filename:  /proc/729/object/a.out
18  symbols read:      3240
19  allocation count:  13
20  allocation peak:   4720 bytes
21  allocation limit:  0 bytes
22  allocated blocks:  1 (16 bytes)
23  freed blocks:      0 (0 bytes)
24  free blocks:       1 (8176 bytes)
25  internal blocks:   25 (204800 bytes)
26  total heap usage:  212992 bytes
27  total warnings:    0
28  total errors:      1
@end smallexample

@enumerate 1
@item
System page size.  This value is used on some platforms when allocating and
protecting system memory.

@cindex alignment
@cindex misaligned data
@cindex bus errors
@item
Default alignment.  This value is the minimum alignment required for general
purpose memory allocations, and is usually the alignment required by the most
restrictive datatype on a given system.  It is used when allocating memory that
has no specified alignment.  It can be changed at run-time using the
@option{DEFALIGN} option, but setting this value too small may cause the program
to crash due to bus errors which are caused by reading from or writing to
misaligned data.

@cindex overflow buffers
@cindex buffers, overflow
@cindex overflow size
@item
Overflow size.  This value is the size used by one overflow buffer.  If this is
non-zero then every memory allocation will have two overflow buffers; one on
either side.  These buffers are used by the library to detect if the program
has written too many bytes to a memory allocation, thus overflowing into one of
the buffers, but these extra checks can slow down execution speed.  It can be
changed at run-time using the @option{OFLOWSIZE} option.

@cindex overflow byte
@item
Overflow byte.
@cindex allocation byte
@item
Allocation byte.
@cindex free byte
@item
Free byte.  These values are used by the library to pre-fill blocks of memory
for checking purposes.  The overflow byte is used to fill overflow buffers, the
allocation byte is used to fill newly-allocated memory (except from
@code{calloc()} or @code{recalloc()}), and the free byte is used to fill free
blocks or freed memory allocations.  These can be changed at run-time using the
@option{OFLOWBYTE}, @option{ALLOCBYTE} and @option{FREEBYTE} options.

@cindex debugger
@cindex halting the library
@item
Allocation stop.
@item
Reallocation stop.
@item
Free stop.  These values are used by the library to halt the program when run
inside a debugger whenever a specified allocation index is allocated,
reallocated or freed.  These can be changed at run-time using the
@option{ALLOCSTOP}, @option{REALLOCSTOP} and @option{FREESTOP} options.

@cindex unfreed allocations
@item
Unfreed abort.  This value is used when the program terminates and is used by
the library to check if there are more than a given number of unfreed memory
allocations.  If there are then the library will cause the program to abort
with an error.  It can be changed at run-time using the @option{UNFREEDABORT}
option.

@item
Lower check range.
@item
Upper check range.  These values specify the range of allocation indices through
which the library will physically check every area of free memory and every
overflow buffer for errors.  A dash specifies that either the lower or upper
range is infinite, but if they are both zero then no such checking will ever be
performed, thus speeding up execution speed dramatically.  The library defaults
to performing checks for every allocation index.  These can be changed at
run-time using the @option{CHECK} option.

@cindex callback functions
@cindex functions, callback
@cindex handler functions
@cindex functions, handler
@cindex prologue function
@item
Prologue function.
@cindex epilogue function
@item
Epilogue function.
@cindex low memory handler function
@item
Handler function.  These values contain addresses or names of functions that
have been installed as callback functions for the library.  These functions, if
set, will be called from the library at appropriate times during program
execution in order to handle specific events.  These can be changed at
compile-time using the @code{__mp_prologue()}, @code{__mp_epilogue()} and
@code{__mp_nomemory()} functions.

@item
Log file.  Simply contains the name of the file where all mpatrol library
diagnostics go to.  It can be changed at run-time using the @option{LOGFILE}
option.

@item
Program filename.  Contains the full pathname to the program's executable file.
This is used by the mpatrol library to read the symbol table in order to
provide symbolic information in function call stacks.  It can be changed at
run-time using the @option{PROGFILE} option.

@item
Symbols read.  This value contains the total number of symbols read from a
program's executable file and/or the dynamic linker, if applicable.

@item
Allocation count.  This value contains the total number of memory allocations
that were created by the mpatrol library.  This value may be more than expected
if the mpatrol library makes any memory allocations during initialisation.

@cindex peak memory usage
@cindex memory usage
@item
Allocation peak.  This value contains the peak memory usage set by the program
when running.  This value may be more than expected if the mpatrol library makes
any memory allocations during initialisation.

@cindex limiting available memory
@item
Allocation limit.  This value is used to limit the amount of memory that can be
allocated by a program, which can be useful for stress-testing in simulated low
memory conditions.  It can be changed at run-time using the @option{LIMIT}
option.

@cindex memory blocks
@cindex blocks
@item
@cindex allocated blocks
Allocated blocks.
@item
@cindex freed blocks
Freed blocks.
@item
@cindex free blocks
Free blocks.  These values contain the total number of allocated, freed and
free blocks at the time the summary was produced.  A freed block is an allocated
block that has been freed but has not been returned to the free memory list for
later allocation.  These values may be different from those expected if the
mpatrol library makes any memory allocations during initialisation.

@cindex internal blocks
@item
Internal blocks.  This value contains the total number of memory blocks (of
varying sizes) that have been allocated from the system for the mpatrol library
to use internally.  These memory blocks will be write-protected on systems that
support memory protection in order to prevent the program from corrupting the
library's data structures.  This can be overridden at run-time using the
@option{NOPROTECT} option in order to speed up program execution slightly.

@cindex heap usage
@item
Total heap usage.  This value contains the total amount of system heap memory
that has been allocated by the mpatrol library.

@item
Total warnings.
@item
Total errors.  The library keeps a count of the total number of warnings and
errors it has displayed so that you can quickly work out this information at
program termination.
@end enumerate

@node Example 2, Example 3, Example 1, Examples
@section Detecting incorrect reuse of freed memory

The next example uses @file{tests/fail/test2.c} to illustrate how the mpatrol
library can detect whereabouts on the heap an address belongs.

@smallexample
23  /*
24   * Allocates a block of 16 bytes and then immediately frees it.  An
25   * attempt is then made to double the size of the original block.
26   */


29  #include "mpatrol.h"


32  int main(void)
33  @{
34      char *p;

36      if (p = (char *) malloc(16))
37      @{
38          free(p);
39          p = (char *) realloc(p, 32);
40      @}
41      return EXIT_SUCCESS;
42  @}
@end smallexample

The relevant excerpts from @file{mpatrol.log} appear below.  The format of the
log messages should be familiar to you now.

@smallexample
ALLOC: malloc (13, 16 bytes, 8 bytes) [main|test2.c|36]
        0x00010B18 main
        0x00010A0C _start

returns 0x00028000

FREE: free (0x00028000) [main|test2.c|38]
        0x00010B54 main
        0x00010A0C _start

    0x00028000 (16 bytes) @{malloc:13:0@} [main|test2.c|36]
        0x00010B18 main
        0x00010A0C _start

REALLOC: realloc (0x00028000, 32 bytes, 8 bytes) [main|test2.c|39]
        0x00010B88 main
        0x00010A0C _start

ERROR: realloc: 0x00028000 has not been allocated

returns 0x00000000
@end smallexample

@cindex tree structure
The mpatrol library stores all of its information about allocated and free
memory in tree structures so that it can quickly determine if an address belongs
to allocated or free memory, or if it even exists in the heap that is managed by
mpatrol.  The above example should illustrate this since after the allocation
had been freed, the library recognised this and reported an error.  It was
possible for the program to continue execution even after that error since
mpatrol could recover from it and return @samp{NULL}.

It is possible for mpatrol to give even more useful diagnostics in the above
situation by using the @option{NOFREE} option.  This prevents the library from
returning any freed allocations to the free memory pool, by preserving any
information about them and marking them as freed.  If you add the
@option{NOFREE} option to the @env{MPATROL_OPTIONS} environment variable you
should see the following entries in @file{mpatrol.log} instead.

@smallexample
ALLOC: malloc (13, 16 bytes, 8 bytes) [main|test2.c|36]
        0x00010B18 main
        0x00010A0C _start

returns 0x00029DE0

FREE: free (0x00029DE0) [main|test2.c|38]
        0x00010B54 main
        0x00010A0C _start

    0x00029DE0 (16 bytes) @{malloc:13:0@} [main|test2.c|36]
        0x00010B18 main
        0x00010A0C _start

REALLOC: realloc (0x00029DE0, 32 bytes, 8 bytes) [main|test2.c|39]
        0x00010B88 main
        0x00010A0C _start

ERROR: realloc: 0x00029DE0 was freed with free
    0x00029DE0 (16 bytes) @{free:13:0@} [main|test2.c|38]
        0x00010B54 main
        0x00010A0C _start

returns 0x00000000
@end smallexample

Note the extra information reported by @code{realloc()} since the library knows
all of the details about the freed memory allocation and when it was freed.

@cindex prevent freeing memory
The @option{NOFREE} option tends to use up much more system memory than normal
since it effectively instructs the mpatrol library to allocate new memory for
every single memory allocation or reallocation.  It can also slow down program
execution when overflow buffers are used, since with each new memory allocation
the library needs to check more and more overflow buffers every time it is
called.  However, it can be quite useful for problems such as this one.  The
test in @file{tests/fail/test3.c} has a similar situation.

@cindex preserve freed contents
Normally, the @option{NOFREE} option will cause the library to fill all freed
memory allocations with the free byte.  However, the original contents of such
allocations can be preserved with the @option{PRESERVE} option.  This could
help in situations when you need to determine exactly if a program is relying on
the contents of freed memory.

@node Example 3, Example 4, Example 2, Examples
@section Detecting use of free memory

This next example illustrates how the mpatrol library is able to check to see
if anything has been written into free memory.  The test is located in
@file{tests/fail/test4.c} and simply writes a single byte into free memory.

@smallexample
23  /*
24   * Allocates a block of 16 bytes and then immediately frees it.  A
25   * NULL character is written into the middle of the freed memory.
26   */


29  #include "mpatrol.h"


32  int main(void)
33  @{
34      char *p;

36      if (p = (char *) malloc(16))
37      @{
38          free(p);
39          p[8] = '\0';
40      @}
41      return EXIT_SUCCESS;
42  @}
@end smallexample

The following output was produced as part of @file{mpatrol.log}.  Note that this
test was run using the same @env{MPATROL_OPTIONS} settings as the last example,
but make sure that @option{PRESERVE} is not set.

@smallexample
ERROR: freed allocation 0x00029DE0 has memory corruption at 0x00029DE8
        0x00029DE8  00555555 55555555                    .UUUUUUU

    0x00029DE0 (16 bytes) @{free:13:0@} [main|test4.c|38]
        0x00010B1C main
        0x000109D4 _start
@end smallexample

The library was able to detect that something had been written into free memory
and could report on the memory allocation that was overwritten.  However, these
checks are only performed whenever a function in the mpatrol library is called.
In the example above, the code which wrote into free memory could have been
miles away from where the library detected the error.

On platforms that support memory protection, the library also supports the
@option{PAGEALLOC} option.  This option instructs the library to force every
single memory allocation to have a size which is a multiple of the system page
size.  Although the library still stores the original requested size, it
effectively means that no two memory allocations occupy the same page of memory.
It can then use page protection (which only operates on pages of memory) to
protect all free memory from being read from or written to, and uses similar
features to install a page of overflow buffer on either side of the allocation.

@cindex fitting allocations
However, if the requested size for the memory allocation was not a multiple of
the page size this means that there will still be unused space left over in the
allocated pages.  This problem is solved by turning the unused space into
overflow buffers that will be checked in the normal way.  The positioning of the
allocation within its pages is also important.  If you want to check for illegal
reads from the borders of the memory allocation, unless it fits exactly into its
pages then there is a chance that a program could illegally read the right-most
overflow buffer if the allocation was left-aligned, or vice-versa.  Two settings
therefore exist for the @option{PAGEALLOC} option: @option{LOWER} and
@option{UPPER}.  They refer to the placement of every memory allocation within
its constituent pages.

The following diagram illustrates the @option{PAGEALLOC} option.  In the
diagram, the system page size is assumed to be 16 bytes (very unlikely, but will
serve for this example) and each character represents 1 byte.

@smallexample
x = allocated memory
o = overflow buffer (filled with the overflow byte)
. = overflow buffer page (read and write protected)

PAGEALLOC=LOWER, allocation size is 16 bytes or
PAGEALLOC=UPPER, allocation size is 16 bytes:
    ................xxxxxxxxxxxxxxxx................

PAGEALLOC=LOWER, allocation size is 8 bytes:
    ................xxxxxxxxoooooooo................

PAGEALLOC=UPPER, allocation size is 8 bytes:
    ................ooooooooxxxxxxxx................
@end smallexample

In our original example, if the @option{PAGEALLOC=LOWER} option is added to the
@env{MPATROL_OPTIONS} environment variable then the following error will be
produced instead of the original error.

@smallexample
ERROR: illegal memory access at address 0x0009E008
    0x0009E000 (16 bytes) @{free:13:0@} [main|test4.c|38]
        0x00010B1C main
        0x000109D4 _start

    call stack
        0x00010B1C main
        0x000109D4 _start
@end smallexample

@cindex signal handler
@cindex illegal memory accesses
On systems that support memory protection, the mpatrol library has a built-in
signal handler which catches illegal memory accesses and terminates the program.
In the above case, the freed memory was made write-protected and so could not be
written to.  The underlying virtual memory system in the operating system
noticed this and signaled this to the library immediately after it happened.

Along with the details of the freed memory allocation that was being written to,
the library also attempts to display the function call stack for the location in
the program that caused the illegal memory access, although this can be quite
unreliable.  A better solution would be to run the program in a debugger to
catch the illegal memory access.

Note that the @option{PAGEALLOC} option also modifies the behaviour of the
@option{NOFREE} and @option{PRESERVE} options when used together.  The memory
allocation being freed will always be made write-protected when the
@option{PRESERVE} option is used, otherwise it will also be made read-protected
to prevent further accesses.

Note also that the @option{PAGEALLOC=UPPER} option is potentially much less
efficient at catching illegal memory accesses than the @option{PAGEALLOC=LOWER}
option.  This is due to alignment requirements, since an allocation of 1 byte
requiring an alignment of 16 bytes cannot be placed at the very end of a page of
size 4096 bytes.  The following diagram illustrates this, using the same page
size as the last diagram.

@smallexample
x = allocated memory
o = overflow buffer (filled with the overflow byte)
. = overflow buffer page (read and write protected)

PAGEALLOC=UPPER, allocation size is 16 bytes, alignment is 8 bytes:
    ................xxxxxxxxxxxxxxxx................

PAGEALLOC=UPPER, allocation size is 3 bytes, alignment is 1 byte:
    ................oooooooooooooxxx................

PAGEALLOC=UPPER, allocation size is 3 bytes, alignment is 8 bytes:
    ................ooooooooxxxooooo................
@end smallexample

Everything is OK until the last allocation, where the alignment requirement
means that there must be two overflow buffers.  This slows down program
execution since the library must check an additional overflow buffer, and also
means that the program would have to read six bytes beyond the end of the
allocation before the illegal memory access would be detected.

@node Example 4, Example 5, Example 3, Examples
@section Using overflow buffers

This example illustrates the use of overflow buffers and so the
@env{MPATROL_OPTIONS} environment variable should have @option{OFLOWSIZE=2}
added to it.  However, turn off any @option{PAGEALLOC} options for the purposes
of this example.  The test is located in @file{tests/fail/test5.c}, and
@file{tests/fail/test6.c} is very similar.

@smallexample
23  /*
24   * Allocates a block of 16 bytes and then copies a string of 16
25   * bytes into the block.  However, the string is copied to 1 byte
26   * before the allocated block which writes before the start of the
27   * block.  This test must be run with an OFLOWSIZE greater than 0.
28   */


31  #include "mpatrol.h"


34  int main(void)
35  @{
36      char *p;

38      if (p = (char *) malloc(16))
39      @{
40          strcpy(p - 1, "this test fails!");
41          free(p);
42      @}
43      return EXIT_SUCCESS;
44  @}
@end smallexample

The following error should be produced in @file{mpatrol.log}.

@smallexample
ERROR: allocation 0x00029E28 has a corrupted overflow buffer at 0x00029E27
        0x00029E26  AA74                                 t

    0x00029E28 (16 bytes) @{malloc:13:0@} [main|test5.c|38]
        0x00010B0C main
        0x00010A00 _start
@end smallexample

@cindex memory dump
@cindex dumping memory
Once again, the library attempts to show you as much detail as possible about
where the corruption occurred.  Along with showing you a memory dump of the
overflow buffer that was corrupted, it also shows you the allocation to which
the overflow buffer belongs.

Using overflow buffers can reduce the speed of program execution since the
library has to check every buffer whenever it is called, and if the buffers are
larger then they'll take longer to check and will use up more memory.  However,
larger buffers mean that there is less chance of the program writing past one
memory allocation into another.

Alternatively, the @option{CHECK} option can be used to limit the number of
checks that the library has to perform, thus speeding up program execution.
This option specifies a range of allocation indices through which the library
will check overflow buffers and free memory for corruption.  Such checks occur
when they normally would, but only if the current allocation index falls within
the specified range.  This feature can be used when there is a suspicion that
free memory corruption or overflow buffer corruption occurs at a certain point
during program execution, but checking them at every library call would take too
long.

On systems which support software watch points, there is an extra option called
@option{OFLOWWATCH} which allows additional memory protection.  Watch points
allow individual bytes to be read and/or write protected as opposed to just
pages.  The @option{OFLOWWATCH} option installs software watch points at every
overflow buffer instead of requiring the library to check the integrity of the
overflow buffers, and can be used in combination with @option{PAGEALLOC}.
However, software watch points slow down program execution to a crawl since
every machine instruction must be checked individually by the system to see if
it accesses a watch point area.  Slowing the program down by a factor of 10,000
is not uncommon on some systems when the @option{OFLOWWATCH} option is used.

@node Example 5, Example 6, Example 4, Examples
@section Incompatible function calls

This example illustrates how the mpatrol library checks for calls to
incompatible pairs of memory allocation functions.  It requires the use of
C++, although does not use any C++ features except for overloaded operators.
The source is in @file{tests/fail/test7.c}, and @file{tests/fail/test8.c} is
similar.

@smallexample
23  /*
24   * Allocates a block of 16 bytes using C++ operator new[] and then
25   * attempts to free it using C++ operator delete.
26   */


29  #include "mpatrol.h"


32  int main(void)
33  @{
34      char *p;

36      p = new char[16];
37      delete p;
38      return EXIT_SUCCESS;
39  @}
@end smallexample

The relevant parts of @file{mpatrol.log} are shown below.

@smallexample
ALLOC: operator new[] (17, 16 bytes, 8 bytes) [-|-|-]
        0x00010A28 __builtin_vec_new
        0x00010ADC main
        0x000108D0 _start

returns 0x00028000

FREE: operator delete (0x00028000) [-|-|-]
        0x00010A74 __builtin_delete
        0x00010AF0 main
        0x000108D0 _start

ERROR: operator delete: 0x00028000 was allocated with operator new[]
    0x00028000 (16 bytes) @{operator new[]:17:0@} [-|-|-]
        0x00010A28 __builtin_vec_new
        0x00010ADC main
        0x000108D0 _start
@end smallexample

This shows a call to @code{operator new[]}, closely followed by a call to
@code{operator delete}.  However, in C++ calls to @code{operator new[]} must be
matched by calls to @code{operator delete[]} and not @code{operator delete}.
Hence, the library reports this as an error and does not free the memory
allocation.

@node Example 6, , Example 5, Examples
@section Additional useful information

@cindex memory leaks
This last example illustrates the various @option{SHOW} options that are
available for displaying additional information from the mpatrol library at
program termination.  It also shows how to easily detect memory leaks.  Use the
@option{OFLOWSIZE=16}, @option{NOFREE} and @option{SHOWALL} options in
@env{MPATROL_OPTIONS} before running.

@smallexample
 1  /*
 2   * Introduces a memory leak by clobbering a pointer with a new
 3   * memory allocation.  Use with SHOWUNFREED to display it.
 4   */


 7  #include "mpatrol.h"


10  int main(void)
11  @{
12      void *p;

14      p = malloc(4);
15      p = malloc(4);
16      if (p != NULL)
17          free(p);
18      return EXIT_SUCCESS;
19  @}
@end smallexample

@cindex memory map
@cindex map of memory
The information that we are interested in comes after the summary of library
statistics generated in the log file.  The first block of data shows a memory
map of the heap that is being handled by mpatrol.  This can be used to see
graphically where a particular allocation is located, or to look for memory
fragmentation.  The @option{SHOWMAP} option also displays this information.

Note that gaps in the memory map can either be due to space used by internal
memory blocks or to some other memory allocation library using up space.  On
some systems that don't have virtual memory, gaps are likely to be owned by
other processes or belong to the system free memory list.

@smallexample
memory map:
  / 0x8000A000-0x8000A00F overflow (16 bytes)
 |+ 0x8000A010-0x8000A077 allocated (104 bytes) @{malloc:1:0@} [-|-|-]
  \ 0x8000A078-0x8000A087 overflow (16 bytes)
  / 0x8000A088-0x8000A097 overflow (16 bytes)
 |+ 0x8000A098-0x8000A115 freed (126 bytes) @{free:2:0@} [-|-|-]
  \ 0x8000A116-0x8000A125 overflow (16 bytes)
  / 0x8000A126-0x8000A135 overflow (16 bytes)
 |+ 0x8000A136-0x8000AF05 freed (3536 bytes) @{free:3:0@} [-|-|-]
  \ 0x8000AF06-0x8000AF15 overflow (16 bytes)
  / 0x8000AF16-0x8000AF25 overflow (16 bytes)
 |+ 0x8000AF26-0x8000AFA3 freed (126 bytes) @{free:4:0@} [-|-|-]
  \ 0x8000AFA4-0x8000AFB3 overflow (16 bytes)
  / 0x8000AFB4-0x8000AFC3 overflow (16 bytes)
 |+ 0x8000AFC4-0x8000AFC7 allocated (4 bytes) @{malloc:10:0@} [main|test.c|14]
  \ 0x8000AFC8-0x8000AFD7 overflow (16 bytes)
  / 0x8000AFD8-0x8000AFE7 overflow (16 bytes)
 |+ 0x8000AFE8-0x8000AFEB freed (4 bytes) @{free:11:0@} [main|test.c|17]
  \ 0x8000AFEC-0x8000AFFB overflow (16 bytes)
--- 0x8000AFFC-0x8000AFFF free (4 bytes)
    --------------------- gap (12288 bytes)
  / 0x8000E000-0x8000E00F overflow (16 bytes)
 |+ 0x8000E010-0x8000EA27 freed (2584 bytes) @{free:5:0@} [-|-|-]
  \ 0x8000EA28-0x8000EA37 overflow (16 bytes)
  / 0x8000EA38-0x8000EA47 overflow (16 bytes)
 |+ 0x8000EA48-0x8000EAC5 freed (126 bytes) @{free:6:0@} [-|-|-]
  \ 0x8000EAC6-0x8000EAD5 overflow (16 bytes)
  / 0x8000EAD6-0x8000EAE5 overflow (16 bytes)
 |+ 0x8000EAE6-0x8000EB63 freed (126 bytes) @{free:8:0@} [-|-|-]
  \ 0x8000EB64-0x8000EB73 overflow (16 bytes)
--- 0x8000EB74-0x8000EFFF free (1164 bytes)
    --------------------- gap (8192 bytes)
  / 0x80011000-0x8001100F overflow (16 bytes)
 |+ 0x80011010-0x800127F7 freed (6120 bytes) @{free:7:0@} [-|-|-]
  \ 0x800127F8-0x80012807 overflow (16 bytes)
--- 0x80012808-0x80012FFF free (2040 bytes)
    --------------------- gap (106496 bytes)
  / 0x8002D000-0x8002D00F overflow (16 bytes)
 |+ 0x8002D010-0x8002DBBF freed (2992 bytes) @{free:9:0@} [-|-|-]
  \ 0x8002DBC0-0x8002DBCF overflow (16 bytes)
--- 0x8002DBD0-0x8002DFFF free (1072 bytes)
@end smallexample

@cindex symbol summary
The next block of data shows a summary of all the symbols that could be read
from the program's executable file and/or any shared libraries that the program
requires.  This can be useful to see which symbols have actually been read by
the mpatrol library.  The @option{SHOWSYMBOLS} option also displays this
information.

Note that the following data has been dramatically cut down in size for the
purposes of this example.  The @samp{@dots{}} marks text that has been removed.

@smallexample
symbols read: 2438
    0x8000076C-0x800007D9 _init [/proc/789/exe] (110 bytes)
    0x80000900-0x8000094F _start [/proc/789/exe] (80 bytes)
    0x80000950-0x8000096F __do_global_dtors_aux [/proc/789/exe] (32 bytes)
    0x80000970-0x80000977 fini_dummy [/proc/789/exe] (8 bytes)
    @dots{}
    0x80003B24-0x80003B4B __clear_cache [/proc/789/exe] (40 bytes)
    0x80003B4C-0x80003B6F __do_global_ctors_aux [/proc/789/exe] (36 bytes)
    0x80003B70-0x80003B77 init_dummy [/proc/789/exe] (8 bytes)
    0x80003B78-0x80003BA9 _fini [/proc/789/exe] (50 bytes)
    0xC0002604-0xC0002609 _start [/lib/ld.so.1] (6 bytes)
    0xC000260A-0xC0002659 _dl_start_user [/lib/ld.so.1] (80 bytes)
    0xC000265A-0xC0002B1B _dl_start [/lib/ld.so.1] (1218 bytes)
               0xC000266A here [/lib/ld.so.1] (0 bytes)
    @dots{}
    0xC0007A78-0xC0007AB5 __libc_read [/lib/ld.so.1] (62 bytes)
               0xC0007A78 read [/lib/ld.so.1] (0 bytes)
               0xC0007A9A __syscall_error [/lib/ld.so.1] (0 bytes)
    0xC0007AB8-0xC0007ADF __clear_cache [/lib/ld.so.1] (40 bytes)
    0xC0013E70-0xC0013E8B __mp_newlist [/usr/lib/libmpatrol.so.1.0] (28 bytes)
    0xC0013E8C-0xC0013EB3 __mp_addhead [/usr/lib/libmpatrol.so.1.0] (40 bytes)
    0xC0013EB4-0xC0013EE7 __mp_addtail [/usr/lib/libmpatrol.so.1.0] (52 bytes)
    0xC0013EE8-0xC0013F1B __mp_prepend [/usr/lib/libmpatrol.so.1.0] (52 bytes)
    @dots{}
    0xC001A0DC-0xC001A0FF __nw__FUi [/usr/lib/libmpatrol.so.1.0] (36 bytes)
    0xC001A100-0xC001A123 __arr_nw__FUi [/usr/lib/libmpatrol.so.1.0] (36 bytes)
    0xC001A124-0xC001A143 __dl__FPv [/usr/lib/libmpatrol.so.1.0] (32 bytes)
    0xC001A144-0xC001A163 __arr_dl__FPv [/usr/lib/libmpatrol.so.1.0] (32 bytes)
    0xC003BB14-0xC003BB45 __libc_global_ctors [/lib/libc.so.6] (50 bytes)
    0xC003BB48-0xC003BB97 __libc_init [/lib/libc.so.6] (80 bytes)
    0xC003BB98-0xC003BBC3 __libc_print_version [/lib/libc.so.6] (44 bytes)
    0xC003BBC4-0xC003BBD7 __libc_main [/lib/libc.so.6] (20 bytes)
    @dots{}
    0xC008F8BC-0xC008FA4D __moddi3 [/lib/libc.so.6] (402 bytes)
    0xC008FA50-0xC008FB19 __udivdi3 [/lib/libc.so.6] (202 bytes)
    0xC008FB1C-0xC008FC1B __umoddi3 [/lib/libc.so.6] (256 bytes)
    0xC008FC1C-0xC008FC4D _fini [/lib/libc.so.6] (50 bytes)
@end smallexample

The next block of data shows a summary of all freed memory allocations.  This is
only possible because the @option{NOFREE} option was also given, otherwise there
would be no details on freed memory allocations.  All of these entries show
where the allocation was freed, which can be useful if you quickly needed to see
where an allocation was freed.  The @option{SHOWFREED} option also displays this
information.

As this example was run on UNIX, the mpatrol library replaces the default
implementations of @code{malloc()}, @code{free()}, etc.  As can be seen below,
this allows the library to trace all calls to allocate dynamic memory in a
process, even from functions that were not compiled with mpatrol.  The two
functions shown below were called by the mpatrol library in order to read the
symbols from ELF object files.  However, they are located in the ELF access
library which was not compiled with mpatrol.

Note that the following data has again been cut down in size for the purposes of
this example.  The @samp{@dots{}} marks text that has been removed.

@smallexample
freed allocations: 9 (15740 bytes)
    0x8000A098 (126 bytes) @{free:2:0@} [-|-|-]
        0x800011BC elf_end
        0xC0019668 __mp_init
        0xC001982A __mp_alloc
        0x8000099C main
        0x80000944 _start

    0x8000A136 (3536 bytes) @{free:3:0@} [-|-|-]
        0x8000104E _elf_free
        0xC0019668 __mp_init
        0xC001982A __mp_alloc
        0x8000099C main
        0x80000944 _start

    @dots{}
@end smallexample

The final block of data shows a summary of all unfreed memory allocations.  This
can show up memory leaks, although the first unfreed memory allocation in this
example comes from the standard C library.  On systems such as UNIX it does not
really matter about these unfreed allocations since they will automatically be
returned to the system on process termination.

However, the second unfreed allocation shows an example of a memory leak, where
no pointers referencing that allocation remain in the program to free it with.
If this was within a loop then the program could quickly run away with memory,
causing at least a decrease in performance, and at most a memory shortage.  The
mpatrol library makes it easier to spot memory leaks.

The @option{SHOWUNFREED} option also displays this information.

@smallexample
unfreed allocations: 2 (108 bytes)
    0x8000A010 (104 bytes) @{malloc:1:0@} [-|-|-]
        0xC0052B4A _IO_fopen
        0xC0017A0C __mp_openlogfile
        0xC0019648 __mp_init
        0xC001982A __mp_alloc
        0x8000099C main
        0x80000944 _start

    0x8000AFC4 (4 bytes) @{malloc:10:0@} [main|test.c|14]
        0x8000099C main
        0x80000944 _start
@end smallexample

@node Functions, Environment, Examples, Top
@appendix Functions
@cindex functions
@cindex library functions

@cindex mpatrol.h
@cindex MPATROL_VERSION
The mpatrol library contains implementations of dynamic memory allocation
functions for C and C++ suitable for tracing and debugging.  The library is
intended to be used without requiring any changes to existing user source code
except the inclusion of the @file{mpatrol.h} header file, although additional
functions are supplied for extra tracing and control.  Note that the current
version of the mpatrol library is contained in the @code{MPATROL_VERSION}
preprocessor macro.

The following 13 functions are available as replacements for existing C library
functions.  To use these you must include @file{mpatrol.h} before all other
header files, although on UNIX platforms they will be used anyway, albeit with
slightly less tracing information.

@table @asis
@findex malloc
@item @code{void *malloc(size_t size)}
Allocates @var{size} uninitialized bytes from the heap and returns a pointer to
the first byte of the allocation.  The pointer returned will be suitably aligned
for casting to any type and can be used to store data of up to @var{size} bytes
in length.  If @var{size} is @samp{0} then the memory allocated will be
implicitly rounded up to @samp{1} byte.  If there is not enough space in the
heap then the @samp{NULL} pointer will be returned and @code{errno} will be set
to @code{ENOMEM}.  The allocated memory must be deallocated with @code{free()}
or reallocated with @code{realloc()}.

@findex calloc
@item @code{void *calloc(size_t nelem, size_t size)}
Allocates @var{nelem} elements of @var{size} zero-initialized bytes from the
heap and returns a pointer to the first byte of the allocation.  The pointer
returned will be suitably aligned for casting to any type and can be used to
store data of up to @code{nelem * size} bytes in length.  If @code{nelem * size}
is @samp{0} then the amount of memory allocated will be implicitly rounded up to
@samp{1} byte.  If there is not enough space in the heap then the @samp{NULL}
pointer will be returned and @code{errno} will be set to @code{ENOMEM}.  The
allocated memory must be deallocated with @code{free()} or reallocated with
@code{realloc()}.

@findex memalign
@item @code{void *memalign(size_t align, size_t size)}
Allocates @var{size} uninitialized bytes from the heap and returns a pointer to
the first byte of the allocation.  The pointer returned will be aligned to
@var{align} bytes and can be used to store data of up to @var{size} bytes in
length.  If @var{align} is zero then the default system alignment will be used.
If @var{align} is not a power of two then it will be rounded up to the nearest
power of two.  If @var{align} is greater than the system page size then it will
be truncated to that value.  If @var{size} is @samp{0} then the memory allocated
will be implicitly rounded up to @samp{1} byte.  If there is not enough space in
the heap then the @samp{NULL} pointer will be returned and @code{errno} will be
set to @code{ENOMEM}.  The allocated memory must be deallocated with
@code{free()} or reallocated with @code{realloc()}, although the latter will not
guarantee the preservation of alignment.

@findex valloc
@item @code{void *valloc(size_t size)}
Allocates @var{size} uninitialized bytes from the heap and returns a pointer to
the first byte of the allocation.  The pointer returned will be aligned to the
system page size and can be used to store data of up to @var{size} bytes in
length.  If @var{size} is @samp{0} then the memory allocated will be implicitly
rounded up to @samp{1} byte.  If there is not enough space in the heap then the
@samp{NULL} pointer will be returned and @code{errno} will be set to
@code{ENOMEM}.  The allocated memory must be deallocated with @code{free()} or
reallocated with @code{realloc()}, although the latter will not guarantee the
preservation of alignment.

@findex pvalloc
@item @code{void *pvalloc(size_t size)}
Allocates @var{size} uninitialized bytes from the heap and returns a pointer to
the first byte of the allocation.  The pointer returned will be aligned to the
system page size and can be used to store data of up to @var{size} bytes in
length.  If @var{size} is @samp{0} then the memory allocated will be implicitly
rounded up to @samp{1} page, otherwise @var{size} will be implicitly rounded up
to a multiple of the system page size.  If there is not enough space in the heap
then the @samp{NULL} pointer will be returned and @code{errno} will be set to
@code{ENOMEM}.  The allocated memory must be deallocated with @code{free()} or
reallocated with @code{realloc()}, although the latter will not guarantee the
preservation of alignment.

@findex strdup
@item @code{char *strdup(char *str)}
Allocates exactly enough memory from the heap to duplicate @var{str} (including
the terminating nul character) and returns a pointer to the first byte of the
allocation after copying @var{str} to the newly-allocated memory.  The pointer
returned will have no alignment constraints and can be used to store character
data up to the length of @var{str}.  If @var{str} is @samp{NULL} then the
@samp{NULL} pointer will be returned.  If there is not enough space in the heap
then the @samp{NULL} pointer will be returned and @code{errno} will be set to
@code{ENOMEM}.  The allocated memory must be deallocated with @code{free()} or
reallocated with @code{realloc()}.

@findex strndup
@item @code{char *strndup(char *str, size_t size)}
Allocates exactly enough memory from the heap to duplicate @var{str} (including
the terminating nul character) and returns a pointer to the first byte of the
allocation after copying @var{str} to the newly-allocated memory.  The pointer
returned will have no alignment constraints and can be used to store character
data up to the length of @var{str}.  If @var{str} is @samp{NULL} then the
@samp{NULL} pointer will be returned.  If the length of @var{str} is greater
than @var{size} then only @var{size} characters will be allocated and copied,
with one additional byte for the nul character.  If there is not enough space in
the heap then the @samp{NULL} pointer will be returned and @code{errno} will be
set to @code{ENOMEM}.  The allocated memory must be deallocated with
@code{free()} or reallocated with @code{realloc()}.  This function is available
for backwards compatibility with older C libraries and should not be used in new
code.

@findex strsave
@item @code{char *strsave(char *str)}
Allocates exactly enough memory from the heap to duplicate @var{str} (including
the terminating nul character) and returns a pointer to the first byte of the
allocation after copying @var{str} to the newly-allocated memory.  The pointer
returned will have no alignment constraints and can be used to store character
data up to the length of @var{str}.  If @var{str} is @samp{NULL} then the
@samp{NULL} pointer will be returned.  If there is not enough space in the heap
then the @samp{NULL} pointer will be returned and @code{errno} will be set to
@code{ENOMEM}.  The allocated memory must be deallocated with @code{free()} or
reallocated with @code{realloc()}.  This function is available for backwards
compatibility with older C libraries and should not be used in new code.

@findex strnsave
@item @code{char *strnsave(char *str, size_t size)}
Allocates exactly enough memory from the heap to duplicate @var{str} (including
the terminating nul character) and returns a pointer to the first byte of the
allocation after copying @var{str} to the newly-allocated memory.  The pointer
returned will have no alignment constraints and can be used to store character
data up to the length of @var{str}.  If @var{str} is @samp{NULL} then the
@samp{NULL} pointer will be returned.  If the length of @var{str} is greater
than @var{size} then only @var{size} characters will be allocated and copied,
with one additional byte for the nul character.  If there is not enough space in
the heap then the @samp{NULL} pointer will be returned and @code{errno} will be
set to @code{ENOMEM}.  The allocated memory must be deallocated with
@code{free()} or reallocated with @code{realloc()}.  This function is available
for backwards compatibility with older C libraries and should not be used in new
code.

@findex realloc
@item @code{void *realloc(void *ptr, size_t size)}
Resizes the memory allocation beginning at @var{ptr} to @var{size} bytes and
returns a pointer to the first byte of the new allocation after copying
@var{ptr} to the newly-allocated memory, which will be truncated if @var{size}
is smaller than the original allocation.  The pointer returned will be suitably
aligned for casting to any type and can be used to store data of up to
@var{size} bytes in length.  If @var{ptr} is @samp{NULL} then the call will be
equivalent to @code{malloc()}.  If @var{size} is @samp{0} then the existing
memory allocation will be freed and the @samp{NULL} pointer will be returned.
If @var{size} is greater than the original allocation then the extra space will
be filled with uninitialized bytes.  If there is not enough space in the heap
then the @samp{NULL} pointer will be returned and @code{errno} will be set to
@code{ENOMEM}.  The allocated memory must be deallocated with @code{free()} and
can be reallocated again with @code{realloc()}.

@findex recalloc
@item @code{void *recalloc(void *ptr, size_t size)}
Resizes the memory allocation beginning at @var{ptr} to @var{size} bytes and
returns a pointer to the first byte of the new allocation after copying
@var{ptr} to the newly-allocated memory, which will be truncated if @var{size}
is smaller than the original allocation.  The pointer returned will be suitably
aligned for casting to any type and can be used to store data of up to
@var{size} bytes in length.  If @var{ptr} is @samp{NULL} then the call will be
equivalent to @code{calloc()}.  If @var{size} is @samp{0} then the existing
memory allocation will be freed and the @samp{NULL} pointer will be returned.
If @var{size} is greater than the original allocation then the extra space will
be filled with zero-initialized bytes.  If there is not enough space in the heap
then the @samp{NULL} pointer will be returned and @code{errno} will be set to
@code{ENOMEM}.  The allocated memory must be deallocated with @code{free()} and
can be reallocated again with @code{realloc()}.  This function is available for
backwards compatibility with older C libraries and @code{calloc()} and should
not be used in new code.

@findex free
@item @code{void free(void *ptr)}
Frees the memory allocation beginning at @var{ptr} so the memory can be reused
by another call to allocate memory.  If @var{ptr} is @samp{NULL} then no memory
will be freed.  All of the previous contents will be destroyed.

@findex cfree
@item @code{void cfree(void *ptr)}
Frees the memory allocation beginning at @var{ptr} so the memory can be reused
by another call to allocate memory.  If @var{ptr} is @samp{NULL} then no memory
will be freed.  All of the previous contents will be destroyed.  This function
is available for backwards compatibilty with older C libraries and
@code{calloc()} and should not be used in new code.
@end table

The following 5 functions are available as replacements for existing C++ library
functions.  To use these you must include @file{mpatrol.h} before all other
header files, although on UNIX platforms they will be used anyway, albeit with
slightly less tracing information.

@table @asis
@findex operator new
@item @code{void *operator new(size_t size)}
Allocates @var{size} uninitialized bytes from the heap and returns a pointer to
the first byte of the allocation.  The pointer returned will be suitably aligned
for casting to any type and can be used to store data of up to @var{size} bytes
in length.  If @var{size} is @samp{0} then the memory allocated will be
implicitly rounded up to @samp{1} byte.  If there is not enough space in the
heap then the @samp{NULL} pointer will be returned and @code{errno} will be set
to @code{ENOMEM} --- no exceptions will be thrown.  The allocated memory must be
deallocated with @code{operator delete}.

@findex operator new[]
@item @code{void *operator new[](size_t size)}
Allocates @var{size} uninitialized bytes from the heap and returns a pointer to
the first byte of the allocation.  The pointer returned will be suitably aligned
for casting to any type and can be used to store data of up to @var{size} bytes
in length.  If @var{size} is @samp{0} then the memory allocated will be
implicitly rounded up to @samp{1} byte.  If there is not enough space in the
heap then the @samp{NULL} pointer will be returned and @code{errno} will be set
to @code{ENOMEM} --- no exceptions will be thrown.  The allocated memory must be
deallocated with @code{operator delete[]}.

@findex operator delete
@item @code{void operator delete(void *ptr)}
Frees the memory allocation beginning at @var{ptr} so the memory can be reused
by another call to allocate memory.  If @var{ptr} is @samp{NULL} then no memory
will be freed.  All of the previous contents will be destroyed.  This function
must only be used with memory allocated by @code{operator new}.

@findex operator delete[]
@item @code{void operator delete[](void *ptr)}
Frees the memory allocation beginning at @var{ptr} so the memory can be reused
by another call to allocate memory.  If @var{ptr} is @samp{NULL} then no memory
will be freed.  All of the previous contents will be destroyed.  This function
must only be used with memory allocated by @code{operator new[]}.

@findex set_new_handler
@item @code{void (*set_new_handler(void (*func)(void)))(void)}
Installs a low-memory handler specifically for use with @code{operator new} and
@code{operator new[]} and returns a pointer to the previously installed handler,
or the @samp{NULL} pointer if no handler had been previously installed.  This
will be called repeatedly by both functions when they would normally return
@samp{NULL}, and this loop will continue until they manage to allocate the
requested space.  Note that this function is equivalent to
@code{__mp_nomemory()} and will replace the handler installed by that function.
@end table

The following 7 functions are available as support routines for additional
control and tracing in the mpatrol library.  To use these you should include the
@file{mpatrol.h} header file.

@table @asis
@findex __mp_info
@cindex allocation information
@cindex information about an allocation
@item @code{int __mp_info(void *ptr, __mp_allocinfo *info)}
Obtains information about a specific memory allocation by placing statistics
about @var{ptr} in @var{info}.  If @var{ptr} does not belong to a previously
allocated memory allocation then @samp{0} will be returned, otherwise @samp{1}
will be returned and @var{info} will contain the following information:

@multitable @columnfractions .2 .8
@item @emph{Field}
@tab @emph{Description}
@item @code{block}
@tab Pointer to first byte of allocation.
@item @code{size}
@tab Size of allocation in bytes.
@item @code{type}
@tab Type of function which allocated memory.
@item @code{alloc}
@tab Allocation index.
@item @code{realloc}
@tab Number of times reallocated.
@item @code{thread}
@tab Thread identifier.
@item @code{func}
@tab Function in which allocation took place.
@item @code{file}
@tab File in which allocation took place.
@item @code{line}
@tab Line number at which allocation took place.
@item @code{stack}
@tab Pointer to function call stack.
@item @code{freed}
@tab Indicates if allocation has been freed.
@end multitable

@findex __mp_memorymap
@item @code{void __mp_memorymap(int stats)}
If @var{stats} is non-zero then the current statistics of the mpatrol library
will be displayed.  If the heap contains at least one allocated, freed or free
block then a map of the current heap will also be displayed.

@findex __mp_summary
@item @code{void __mp_summary(void)}
Displays information about the current state of the mpatrol library, including
its settings and any relevant statistics.

@findex __mp_check
@item @code{void __mp_check(void)}
Forces the library to perform an immediate check of the overflow buffers of
every memory allocation and to ensure that nothing has overwritten any free
blocks.

@findex __mp_prologue
@item @code{void (*__mp_prologue(void (*func)(void *, size_t)))(void *, size_t)}
Installs a prologue function to be called before any memory allocation,
reallocation or deallocation function.  This function will return a pointer to
the previously installed prologue function, or the @samp{NULL} pointer if no
prologue function had been previously installed.  The following arguments will
be used to call the prologue function:

@multitable @columnfractions .2 .2 .6
@item @emph{Argument 1}
@tab @emph{Argument 2}
@tab @emph{Called by}
@item @code{-1}
@tab @var{size}
@tab @code{malloc()}, etc.
@item @var{ptr}
@tab @var{size}
@tab @code{realloc()}, etc.
@item @var{ptr}
@tab @code{-1}
@tab @code{free()}, etc.
@item @var{ptr}
@tab @code{-2}
@tab @code{strdup()}, etc.
@end multitable

@findex __mp_epilogue
@item @code{void (*__mp_epilogue(void (*func)(void *)))(void *)}
Installs an epilogue function to be called after any memory allocation,
reallocation or deallocation function.  This function will return a pointer to
the previously installed epilogue function, or the @samp{NULL} pointer if no
epilogue function had been previously installed.  The following arguments will
be used to call the epilogue function:

@multitable @columnfractions .2 .8
@item @emph{Argument}
@tab @emph{Called by}
@item @var{ptr}
@tab @code{malloc()}, @code{realloc()}, @code{strdup()}, etc.
@item @code{-1}
@tab @code{free()}, etc.
@end multitable

@findex __mp_nomemory
@item @code{void (*__mp_nomemory(void (*func)(void)))(void)}
Installs a low-memory handler and returns a pointer to the previously installed
handler, or the @samp{NULL} pointer if no handler had been previously installed.
This will be called once by C memory allocation functions, and repeatedly by C++
memory allocation functions, when they would normally return @samp{NULL}.  Note
that this function is equivalent to @code{set_new_handler()} and will replace
the handler installed by that function.
@end table

@node Environment, Options, Functions, Top
@appendix Environment
@cindex environment

@cindex MPATROL_OPTIONS
The library can read certain options at run-time from an environment variable
called @env{MPATROL_OPTIONS}.  This variable must contain one or more valid
option keywords from the list below and must be no longer than 256 characters in
length.  If @env{MPATROL_OPTIONS} is unset or empty then the default settings
will be used.

@cindex binary
@cindex octal
@cindex decimal
@cindex hexadecimal
The syntax for options specified within the @env{MPATROL_OPTIONS} environment
variable is @samp{OPTION} or @samp{OPTION=VALUE}, where @samp{OPTION} is a
keyword from the list below and @samp{VALUE} is the setting for that option.  If
@samp{VALUE} is numeric then it may be specified using binary, octal, decimal or
hexadecimal notation, with binary notation beginning with either @samp{0b} or
@samp{0B}.  If @samp{VALUE} is a character string containing spaces then it may
be quoted using double quotes.  No whitespace may appear between the @samp{=}
sign, but whitespace must appear between different options.  Note that option
keywords can be given in lowercase as well as uppercase, or a mixture of both.

@table @asis
@cindex ALLOCBYTE
@item @option{ALLOCBYTE}=<@var{unsigned-integer}>
Specifies an 8-bit byte pattern with which to prefill newly-allocated memory.
This can be used to detect the use of memory which has not been initialised
after allocation.  Note that this setting will not affect memory allocated with
@code{calloc()} or @code{recalloc()} as these functions always prefill allocated
memory with an 8-bit byte pattern of zero.  Default value:
@option{ALLOCBYTE=0xFF}.

@cindex ALLOCSTOP
@item @option{ALLOCSTOP}=<@var{unsigned-integer}>
Specifies an allocation index at which to stop the program when it is being
allocated.  When the number of memory allocations reaches this number the
program will be halted, and its state may be examined at that point by using a
suitable debugger.  Note that this setting will be ignored if its value is zero.
Default value: @option{ALLOCSTOP=0}.

@cindex CHECK
@item @option{CHECK}=<@var{unsigned-range}>
Specifies a range of allocation indices at which to check the integrity of free
memory and overflow buffers.  The range must be specified as no more than two
unsigned integers separated by a dash.  If numbers on either the left side or
the right side of the dash are omitted then they will be assumed to be @samp{0}
and @var{infinity} respectively.  A value of @samp{0} on its own indicates that
no such checking will ever be performed.  This option can be used to speed up
the execution speed of the library at the expense of checking.  Default value:
@option{CHECK=-}.

@cindex CHECKALL
@item @option{CHECKALL}
Equivalent to the @option{CHECKALLOCS}, @option{CHECKREALLOCS} and
@option{CHECKFREES} options specified together.

@cindex CHECKALLOCS
@item @option{CHECKALLOCS}
Checks that no attempt is made to allocate a block of memory of size zero.  A
warning will be issued for every such case.

@cindex CHECKFREES
@item @option{CHECKFREES}
Checks that no attempt is made to deallocate a @samp{NULL} pointer.  A warning
will be issued for every such case.

@cindex CHECKREALLOCS
@item @option{CHECKREALLOCS}
Checks that no attempt is made to reallocate a @samp{NULL} pointer or resize an
existing block of memory to size zero.  Warnings will be issued for every such
case.

@cindex DEFALIGN
@item @option{DEFALIGN}=<@var{unsigned-integer}>
Specifies the default alignment for general-purpose memory allocations, which
must be a power of two (and will be rounded up to the nearest power of two if it
is not).  The default alignment for a particular system is calculated at
run-time.

@cindex FREEBYTE
@item @option{FREEBYTE}=<@var{unsigned-integer}>
Specifies an 8-bit byte pattern with which to prefill newly-freed memory.  This
can be used to detect the use of memory which has just been freed.  It is also
used internally to ensure that freed memory has not been overwritten.  Note that
the freed memory may be reused the next time a block of memory is allocated and
so once memory has been freed its contents are not guaranteed to remain the same
as the specified byte pattern.  Default value: @option{FREEBYTE=0x55}.

@cindex FREESTOP
@item @option{FREESTOP}=<@var{unsigned-integer}>
Specifies an allocation index at which to stop the program when it is being
freed.  When the memory allocation with the specified allocation index is to be
freed the program will be halted, and its state may be examined at that point
using a suitable debugger.  Note that this setting will be ignored if its value
is zero.  Default value: @option{FREESTOP=0}.

@cindex HELP
@cindex option summary
@cindex summary of options
@item @option{HELP}
Displays a quick-reference option summary to the @code{stderr} file stream.

@cindex LIMIT
@cindex stress testing
@item @option{LIMIT}=<@var{unsigned-integer}>
Specifies the limit in bytes at which all memory allocations should fail if the
total allocated memory should increase beyond this.  This can be used to
stress-test software to see how it behaves in low memory conditions.  The
internal memory used by the library itself will not be counted as part of the
total heap size, but on some systems there may be a small amount of memory
required to initialise the library itself.  Note that this setting will be
ignored if its value is zero.  Default value: @option{LIMIT=0}.

@cindex LOGALL
@item @option{LOGALL}
Equivalent to the @option{LOGALLOCS}, @option{LOGREALLOCS} and @option{LOGFREES}
options specified together.

@cindex LOGALLOCS
@item @option{LOGALLOCS}
Specifies that all memory allocations are to be logged and sent to the log file.
Note that any memory allocations made internally by the library will not be
logged.

@cindex LOGFILE
@item @option{LOGFILE}=<@var{string}>
Specifies an alternative file in which to place all diagnostics from the mpatrol
library.  A filename of @samp{stderr} will send all diagnostics to the
@code{stderr} file stream and a filename of @samp{stdout} will do the equivalent
with the @code{stdout} file stream.  Note that if a problem occurs while opening
the log file or if any diagnostics require to be displayed before the log file
has had a chance to be opened then they will be sent to the @code{stderr} file
stream.  Default value: @option{LOGFILE=mpatrol.log}.

@cindex LOGFREES
@item @option{LOGFREES}
Specifies that all memory deallocations are to be logged and sent to the log
file.  Note that any memory deallocations made internally by the library will
not be logged.

@cindex LOGREALLOCS
@item @option{LOGREALLOCS}
Specifies that all memory reallocations are to be logged and sent to the log
file.  Note that any memory reallocations made internally by the library will
not be logged.

@cindex NOFREE
@item @option{NOFREE}
Specifies that the mpatrol library should keep all reallocated and freed memory
allocations.  Such freed memory allocations will then be flagged as freed and
can be used by the library to provide better diagnostics.  However, as no system
memory will ever be reused by the mpatrol library, this option can quickly lead
to a shortage of available system memory for a process.  Note that this option
will always force a memory reallocation to return a pointer to newly-allocated
memory.

@cindex NOPROTECT
@item @option{NOPROTECT}
Specifies that the mpatrol library's internal data structures should not be made
read-only after every memory allocation reallocation or deallocation.  This may
significantly speed up execution but this will be at the expense of less safety
if the program accidentally overwrites some of the library's internal data
structures.  Note that this option has no effect on systems that do not support
memory protection.

@cindex OFLOWBYTE
@item @option{OFLOWBYTE}=<@var{unsigned-integer}>
Specifies an 8-bit byte pattern with which to fill the overflow buffers of all
memory allocations.  This is used internally to ensure that nothing has been
written beyond the beginning or the end of a block of allocated memory.  Note
that this setting will only have an effect if the @option{OFLOWSIZE} option is
in use.  Default value: @option{OFLOWBYTE=0xAA}.

@cindex OFLOWSIZE
@item @option{OFLOWSIZE}=<@var{unsigned-integer}>
Specifies the size in bytes to use for all overflow buffers, which must be a
power of two (and will be rounded up to the nearest power of two if it is not).
This is used internally to ensure that nothing has been written beyond the
beginning or the end of a block of allocated memory.  Note that this setting
specifies the size for only one of the overflow buffers given to each memory
allocation; the other overflow buffer will have an identical size.  No overflow
buffers will be used if this setting is zero.  Default value:
@option{OFLOWSIZE=0}.

@cindex OFLOWWATCH
@item @option{OFLOWWATCH}
Specifies that watch point areas should be used for overflow buffers rather than
filling with the overflow byte.  This can significantly reduce the speed of
program execution.  Note that this option has no effect on systems that do not
support watch point areas.

@cindex PAGEALLOC
@item @option{PAGEALLOC}=<@option{LOWER}|@option{UPPER}>
Specifies that each individual memory allocation should occupy at least one
page of virtual memory and should be placed at the lowest or highest point
within these pages.  This allows the library to place an overflow buffer of one
page on either side of every memory allocation and write-protect these pages as
well as all free and freed memory.  Note that this option has no effect on
systems that do not support memory protection, and is disabled by default on
other systems as it can slow down the speed of program execution.

@cindex PRESERVE
@item @option{PRESERVE}
Specifies that any reallocated or freed memory allocations should preserve their
original contents.  This option must be used with the @option{NOFREE} option and
has no effect otherwise.

@cindex PROGFILE
@item @option{PROGFILE}=<@var{string}>
Specifies an alternative filename with which to locate the executable file
containing the program's symbols.  On most systems, the library will
automatically be able to determine this filename, but on a few systems this
option may have to be used before any or all symbols can be read.

@cindex REALLOCSTOP
@item @option{REALLOCSTOP}=<@var{unsigned-integer}>
Specifies a reallocation index at which to stop the program when a memory
allocation is being reallocated.  If the @option{ALLOCSTOP} option is non-zero
then the program will be halted when the allocation matching that allocation
index is reallocated the specified number of times.  Otherwise the program will
be halted the first time any allocation is reallocated the specified number of
times.  Note that this setting will be ignored if its value is zero.  Default
value: @option{REALLOCSTOP=0}.

@cindex SHOWALL
@item @option{SHOWALL}
Equivalent to the @option{SHOWFREED}, @option{SHOWUNFREED}, @option{SHOWMAP} and
@option{SHOWSYMBOLS} options specified together.

@cindex SHOWFREED
@item @option{SHOWFREED}
Specifies that a summary of all of the freed memory allocations should be
displayed at the end of program execution.  This option must be used in
conjunction with the @option{NOFREE} option and this step will not be performed
if an abnormal termination occurs or if there were no freed allocations.

@cindex SHOWMAP
@item @option{SHOWMAP}
Specifies that a memory map of the entire heap should be displayed at the end of
program execution.  This step will not be performed if an abnormal termination
occurs or if the heap is empty.

@cindex SHOWSYMBOLS
@item @option{SHOWSYMBOLS}
Specifies that a summary of all of the function symbols read from the program's
executable file should be displayed at the end of program execution.  This step
will not be performed if an abnormal termination occurs or if no symbols could
be read from the executable file.

@cindex SHOWUNFREED
@item @option{SHOWUNFREED}
Specifies that a summary of all of the unfreed memory allocations should be
displayed at the end of program execution.  This step will not be performed if
an abnormal termination occurs or if there are no unfreed allocations.

@cindex UNFREEDABORT
@cindex batch testing
@cindex testing, batch
@item @option{UNFREEDABORT}=<@var{unsigned-integer}>
Specifies the minimum number of unfreed allocations at which to abort the
program just before program termination.  A summary of all the allocations will
be displayed on the standard error file stream before aborting.  This option may
be handy for use in batch tests as it can force tests to fail if they do not
free up a minimum number of memory allocations.  Note that this setting will be
ignored if its value is zero.  Default value: @option{UNFREEDABORT=0}.

@cindex USEMMAP
@cindex mmap
@cindex sbrk
@item @option{USEMMAP}
Specifies that the library should use @code{mmap()} instead of @code{sbrk()} to
allocate system memory on UNIX platforms.  This option should be used if there
are problems when using the mpatrol library in combination with another malloc
library which uses @code{sbrk()} to allocate its memory.  It is ignored on
systems that do not support the @code{mmap()} system call.
@end table

@node Options, Supported systems, Environment, Top
@appendix Options
@cindex options
@cindex command line options
@cindex mpatrol command
@cindex shell script

On UNIX platforms, a shell script called @command{mpatrol} is provided to run
commands that have been linked with the mpatrol library.

@smallexample
mpatrol [options] <command> [arguments]
@end smallexample

The @command{mpatrol} command is used to set various mpatrol library
@var{options} when running @var{command} with its @var{arguments}.  In most
cases, @var{command} must have been linked with the mpatrol library, unless the
@option{-d} option is used in which case @var{command} need only have been
dynamically linked.

@cindex process id
All mpatrol library diagnostics are sent to the file @file{mpatrol.%n.log} in
the current directory by default (where @samp{%n} is the current process id) but
this can be changed using the @option{-l} option.  Any existing
@env{MPATROL_OPTIONS} environment variable settings which are not overridden by
@var{options} will be passed through unchanged to the mpatrol library.

All of the following options (except @option{-d}) correspond to their listed
mpatrol library option (@pxref{Environment}).

@table @asis
@cindex -A
@item @option{-A} <@var{unsigned-integer}>
[@option{ALLOCSTOP}]  Specifies an allocation index at which to stop the program
when it is being allocated.

@cindex -a
@item @option{-a} <@var{unsigned-integer}>
[@option{ALLOCBYTE}]  Specifies an 8-bit byte pattern with which to prefill
newly-allocated memory.

@cindex -C
@item @option{-C} <@var{unsigned-range}>
[@option{CHECK}]  Specifies a range of allocation indices at which to check the
integrity of free memory and overflow buffers.

@cindex -c
@item @option{-c}
[@option{CHECKALL}]  Specifies that all arguments to functions which allocate,
reallocate and deallocate memory have rigorous checks performed on them.

@cindex -D
@item @option{-D} <@var{unsigned-integer}>
[@option{DEFALIGN}]  Specifies the default alignment for general-purpose memory
allocations, which must be a power of two.

@cindex -d
@cindex LD_PRELOAD
@item @option{-d}
Specifies that the @env{LD_PRELOAD} environment variable should be set so that
even programs that were not compiled with the mpatrol library can be traced, but
only if they were dynamically linked.  This option will only work if the dynamic
linker recognises the @env{LD_PRELOAD} environment variable.

@cindex -e
@item @option{-e} <@var{string}>
[@option{PROGFILE}]  Specifies an alternative filename with which to locate the
executable file containing the program's symbols.

@cindex -F
@item @option{-F} <@var{unsigned-integer}>
[@option{FREESTOP}]  Specifies an allocation index at which to stop the program
when it is being freed.

@cindex -f
@item @option{-f} <@var{unsigned-integer}>
[@option{FREEBYTE}]  Specifies an 8-bit byte pattern with which to prefill
newly-freed memory.

@cindex -L
@item @option{-L} <@var{unsigned-integer}>
[@option{LIMIT}]  Specifies the limit in bytes at which all memory allocations
should fail if the total allocated memory should increase beyond this.

@cindex -l
@item @option{-l} <@var{string}>
[@option{LOGFILE}]  Specifies an alternative file in which to place all
diagnostics from the mpatrol library.

@cindex -m
@item @option{-m}
[@option{USEMMAP}]  Specifies that the library should use @code{mmap()} instead
of @code{sbrk()} to allocate system memory.

@cindex -N
@item @option{-N}
[@option{NOPROTECT}]  Specifies that the mpatrol library's internal data
structures should not be made read-only after every memory allocation,
reallocation or deallocation.

@cindex -n
@item @option{-n}
[@option{NOFREE}]  Specifies that the mpatrol library should keep all
reallocated and freed memory allocations.

@cindex -O
@item @option{-O} <@var{unsigned-integer}>
[@option{OFLOWSIZE}]  Specifies the size in bytes to use for all overflow
buffers, which must be a power of two.

@cindex -o
@item @option{-o} <@var{unsigned-integer}>
[@option{OFLOWBYTE}]  Specifies an 8-bit byte pattern with which to fill the
overflow buffers of all memory allocations.

@cindex -P
@item @option{-P}
[@option{PAGEALLOC=UPPER}]  Specifies that each individual memory allocation
should occupy at least one page of virtual memory and should be placed at the
highest point within these pages.

@cindex -p
@item @option{-p}
[@option{PAGEALLOC=LOWER}]  Specifies that each individual memory allocation
should occupy at least one page of virtual memory and should be placed at the
lowest point within these pages.

@cindex -R
@item @option{-R} <@var{unsigned-integer}>
[@option{REALLOCSTOP}]  Specifies an allocation index at which to stop the
program when a memory allocation is being reallocated.

@cindex -S
@item @option{-S}
[@option{SHOWMAP} & @option{SHOWSYMBOLS}]  Specifies that a memory map of the
entire heap and a summary of all of the function symbols read from the program's
executable file should be displayed at the end of program execution.

@cindex -s
@item @option{-s}
[@option{SHOWFREED} & @option{SHOWUNFREED}]  Specifies that a summary of all of
the freed and unfreed memory allocations should be displayed at the end of
program execution.

@cindex -U
@item @option{-U} <@var{unsigned-integer}>
[@option{UNFREEDABORT}]  Specifies the minimum number of unfreed allocations at
which to abort the program just before program termination.

@cindex -v
@item @option{-v}
[@option{PRESERVE}]  Specifies that any reallocated or freed memory allocations
should preserve their original contents.

@cindex -w
@item @option{-w}
[@option{OFLOWWATCH}]  Specifies that watch point areas should be used for
overflow buffers rather than filling with the overflow byte.
@end table

@node Supported systems, Notes, Options, Top
@appendix Supported systems
@cindex supported systems
@cindex systems
@cindex platforms

Following is a list of systems on which the mpatrol library has been built and
tested.  The system details include the operating system and version, the
processor type, the object file format and the C compiler used to compile the
library and tests.  The details following each system list any features of the
library that are not (or cannot be) supported on that system.

@cindex DG/UX, Intel 80x86
@itemize @bullet
@item
DG/UX 4.11, Intel Pentium Pro, ELF32, @command{gcc}
@itemize @bullet
@item
The thread-safe version of the library does not work.
@item
The @option{OFLOWWATCH} option has no effect.
@item
The @option{-d} option to the @command{mpatrol} shell script has no effect.
@end itemize

@cindex DG/UX, Motorola 88xx0
@item
DG/UX 4.11, Motorola 88100, ELF32, @command{gcc}
@itemize @bullet
@item
The thread-safe version of the library does not work.
@item
The @option{OFLOWWATCH} option has no effect.
@item
Cannot automatically determine the program filename.
@item
Call stack traversal only works with unoptimised code.
@item
The @option{-d} option to the @command{mpatrol} shell script has no effect.
@end itemize

@cindex DYNIX/ptx, Intel 80x86
@item
DYNIX/ptx 4.5, Intel Pentium Pro, ELF32, @command{cc}
@itemize @bullet
@item
The thread-safe version of the library does not work.
@item
The @option{OFLOWWATCH} option has no effect.
@item
The @option{-d} option to the @command{mpatrol} shell script has no effect.
@end itemize

@cindex HP/UX, HP PA/RISC
@item
HP/UX 10.20, HP PA/RISC 9000, BFD, @command{gcc}
@itemize @bullet
@item
The thread-safe version of the library does not work.
@item
The @option{OFLOWWATCH} option has no effect.
@item
The @option{USEMMAP} option has no effect.
@item
Cannot automatically determine the program filename.
@item
No support for call stack traversal.
@item
The @option{-d} option to the @command{mpatrol} shell script has no effect.
@end itemize

@cindex RedHat
@cindex Linux, Motorola 680x0
@item
RedHat Linux 5.1, Motorola 68040, ELF32, @command{gcc}
@itemize @bullet
@item
The thread-safe version of the library does not work.
@item
The @option{OFLOWWATCH} option has no effect.
@item
The address of an illegal memory access cannot be determined.
@item
The @option{-d} option to the @command{mpatrol} shell script does not work
properly.
@end itemize

@cindex LynxOS, PowerPC
@item
LynxOS 3.0.0, PowerPC, BFD, @command{gcc}
@itemize @bullet
@item
The thread-safe version of the library does not work.
@item
The @option{OFLOWWATCH} option has no effect.
@item
The @option{USEMMAP} option has no effect.
@item
Cannot automatically determine the program filename.
@item
No support for call stack traversal.
@item
The address of an illegal memory access cannot be determined.
@item
The @option{-d} option to the @command{mpatrol} shell script has no effect.
@end itemize

@cindex Solaris, Intel 80x86
@item
Solaris 2.6, Intel Pentium Pro, ELF32, @command{gcc}
@itemize @bullet
@item
The thread-safe version of the library does not work.
@end itemize

@cindex Solaris, SPARC
@item
Solaris 7, SPARC V9, ELF32, @command{gcc}
@itemize @bullet
@item
The thread-safe version of the library does not work.
@end itemize

@cindex AmigaOS, Motorola 680x0
@item
AmigaOS 3.1, Motorola 68040, n/a, SAS/C
@itemize @bullet
@item
The shared version of the library does not work.
@item
No automatic override of @code{malloc()}, etc., without inclusion of
@file{mpatrol.h}.
@item
No memory protection so the @option{PAGEALLOC} option has no effect.
@item
The @option{OFLOWWATCH} option has no effect.
@item
The @option{USEMMAP} option has no effect.
@item
The @option{ALLOCSTOP}, @option{FREESTOP} and @option{REALLOCSTOP} options have
no effect.
@item
No support for call stack traversal.
@item
No support for reading symbols.
@item
No detection of illegal memory accesses.
@end itemize

@cindex Microsoft
@cindex Windows, Intel 80x86
@item
Microsoft Windows NT 4.0, Intel Pentium III, n/a, Microsoft Visual C/C++
@itemize @bullet
@item
No automatic override of @code{malloc()}, etc., without inclusion of
@file{mpatrol.h}.
@item
The @option{OFLOWWATCH} option has no effect.
@item
The @option{USEMMAP} option has no effect.
@item
The @option{ALLOCSTOP}, @option{FREESTOP} and @option{REALLOCSTOP} options have
no effect.
@item
No support for reading symbols.
@item
The address of an illegal memory access cannot be determined.
@end itemize
@end itemize

@menu
* New system support::          Adding a new operating system.
* New processor support::       Adding a new processor architecture.
* New file format support::     Adding a new object file format.
@end menu

@node New system support, New processor support, , Supported systems
@appendixsec Adding a new operating system
@cindex adding a new operating system
@cindex operating systems, adding support

@itemize @bullet
@item
Add a new @code{TARGET} and/or @code{SYSTEM} definition in @file{target.h}.  The
@code{TARGET} macro is for fundamentally different operating systems, whereas
the @code{SYSTEM} macro is for differentiating variations of a particular
operating system.

@item
Make any necessary modifications to @file{config.h}.

@item
Add any support for memory allocation in @file{memory.c}.

@item
Add any support for stack traversal in @file{stack.c}.

@item
Add any support for signals in @file{signals.c}.

@item
Add any support for threads in @file{mutex.c}.

@item
Add a new version and date format (or use an existing one) in @file{version.c}.

@item
Decide if the @code{malloc()} replacements should be used from @file{mpatrol.c}.

@item
Add a new subdirectory in the @file{build} directory that contains a
@file{Makefile} and any other files that are required to build the library on
the new operating system.
@end itemize

@node New processor support, New file format support, New system support, Supported systems
@appendixsec Adding a new processor architecture
@cindex adding a new processor architecture
@cindex processor architectures, adding support

@itemize @bullet
@item
Add a new @code{ARCH} definition in @file{target.h}.

@item
Make any necessary modifications to @file{config.h}.

@item
Add any support for memory allocation in @file{memory.c}.

@item
Add any support for stack traversal in @file{stack.c}.
@end itemize

@node New file format support, , New processor support, Supported systems
@appendixsec Adding a new object file format
@cindex adding a new object file format
@cindex object file formats, adding support

@itemize @bullet
@item
Add a new @code{FORMAT} definition in @file{target.h}.

@item
Make any necessary modifications to @file{config.h}.

@item
Add any support for stack traversal in @file{stack.c}.

@item
Add any support for symbol reading in @file{symbol.c}.
@end itemize

@node Notes, Related software, Supported systems, Top
@appendix Notes
@cindex notes
@cindex known bugs
@cindex bugs
@cindex limitations
@cindex future enhancements
@cindex enhancements

This section contains information about known bugs and limitations in the
mpatrol library as well as listing potential future enhancements.

Bugs should be reported to @email{mpatrol@@cbmamiga.demon.co.uk} along with the
details of the operating system, processor architecture and object file format
that the mpatrol library is being used with --- and don't forget to include the
version of the mpatrol library you are using!  Keep in mind that I only have
access to an Amiga running RedHat Linux/m68k 5.1 and AmigaOS 3.1, so I will be
most likely unable to reproduce most of the system-specific bugs.  A bug report
that comes with an associated fix will be most welcome.

Enhancement requests and source code containing enhancements should also be sent
to @email{mpatrol@@cbmamiga.demon.co.uk}.  If you are planning to implement an
enhancement, let me know first in case I am (or someone else is) working towards
the same goal --- that way, work won't be wasted.  If you wish to send me source
code changes please send the changes as context diffs or in an e-mail attachment
as a compressed tar archive.

@menu
* Generic notes::               Notes for all platforms.
* UNIX notes::                  Notes for UNIX platforms.
* Amiga notes::                 Notes for Amiga platforms.
* Windows notes::               Notes for Windows platforms.
* Netware notes::               Notes for Netware platforms.
@end menu

@node Generic notes, UNIX notes, , Notes
@appendixsec Notes for all platforms
@cindex notes for all platforms
@cindex platform-independent notes

@itemize @bullet
@item
C++ support is very limited, and will only really work for old C++ code due to
the way the operators are overridden (i.e. there are no exceptions versions of
the functions and they are not defined in a namespace).  There are also likely
to be problems with the macros which redefine @code{malloc()}, etc., since there
may be member functions in code that will mistakenly be redefined if their names
match the macro definitions.  Note also that I haven't yet figured out a way to
pass down the function, filename and line number from a call to @code{operator
new}, for example.  Perhaps there isn't one and it would have to be done from
within the compiler.

@item
Need to add support for 64-bit processors.  This shouldn't be too hard, but I
haven't got access to a 64-bit environment to test it, so I haven't bothered
yet.

@item
The thread-safe code in the library doesn't yet work properly, probably because
of the recursion flag which is incremented or decremented before the mutex is
locked.  Hence, the threads test (@file{tests/pass/test5.c}) doesn't work yet.

@item
Need to make the library re-entrant.  This could be achieved by moving the
static variables in @file{memory.c}, @file{mutex.c}, @file{diag.c} and
@file{option.c} into the @code{infohead} structure and then having an array of
@code{infohead} structures from which to allocate new memory headers when a new
one is required.  This is only necessary for Amiga shared libraries and Netware
NLMs since UNIX and Windows platforms allocate a new copy of the data section in
a shared library or DLL when it is opened by a new process.

@item
The current implementation of call stack traversal is limited and will only
likely work for unoptimised code.  A much better solution would be write the
implementation at a lower level in assembly, but this is much less portable.
Perhaps there is a library which can be used to perform this across many
operating systems and processor architectures, or maybe someone would like to
write one?  I can think of many applications that would benefit from such a
library besides this one.

@item
An alternative implementation for call stack traversal uses the functions
@code{__builtin_frame_address()} and @code{__builtin_return_address()} that are
available when the library is compiled with @command{gcc}.  However, they can
only traverse a number of stack frames at compile-time, not run-time so there is
a maximum number of stack frames that can be traversed at any one time.  The
implementation depends on both of these builtin functions returning @samp{NULL}
when the top of stack is reached.  If this is not the case then this method
cannot be used.

@item
An option should be added to suppress stack traversal, and therefore symbol
reading, in case of problems where the library crashes during reading a call
stack.  An option should also be added to suppress the saving and restoring of
signals upon entry and exit of the mpatrol library, since this would make it
easier to interrupt programs.

@item
In object file formats that support nested symbols (such as ELF), the current
implementation will tend to show some shortcomings.  This is because there is
currently no nesting count in the function that deals with symbol name lookup,
so the wrong symbol name may be displayed in diagnostics.

@item
In object file formats that don't store the sizes of symbols (such as basic
COFF, or when using the GNU BFD library), the current implementation will simply
assume that the current symbol terminates at the beginning of the next symbol in
the virtual address space.

@item
Perhaps debugging information could be utilised when the library is reading the
symbol table from an executable file.  This could be used to add line number
information to the call stack, but could also be used to extend the library to
monitor static and stack variables.

@item
Possibly add ability to interface with various debuggers, including
@command{gdb}, which could be used to provide reliable stack traces and symbolic
information as well as complete debugging information if available.

@item
Add a @option{SHOWFREE} option to display a list of all free memory blocks at
program termination for debugging purposes to view memory fragmentation.  If
that option is added then perhaps @option{SHOWALL} should only be equivalent to
@option{SHOWFREE}, @option{SHOWFREED} and @option{SHOWUNFREED}, and
@option{SHOWMAP} and @option{SHOWSYMBOLS} should be explicitly given.

@item
Add versions of @code{mallopt()}, @code{mallinfo()}, @code{memorymap()} and
@code{mallocctl()} which are provided in many other malloc libraries.  These
won't necessarily behave in exactly the same way as existing implementations,
but at least there won't be link errors when compiling source code which uses
them.

@item
Script files similar to the @command{mpatrol} shell script provided for UNIX
platforms could be added for the other operating systems that the mpatrol
library is available on.  Perhaps this could even be extended to a common
executable command that is written in C.

@item
Add a document containing frequently asked questions.

@item
Perhaps use a configure script to automatically work out values for
@file{config.h} on the platform it is being built on, and provide locations for
installing files.
@end itemize

@node UNIX notes, Amiga notes, Generic notes, Notes
@appendixsec Notes for UNIX platforms
@cindex notes for UNIX platforms
@cindex UNIX notes

@itemize @bullet
@item
Need to add watch point area support for non-Solaris operating systems.  This
may be a case of preventing all heap memory from being accessed and providing a
signal handler that is called when a read from or write to such memory triggers
a signal.  The handler could then determine if the address is in a watch point,
and if it is not it could unprotect the memory and return.

@item
Need to improve watch point facility in order to speed it up by an order of
magnitudes.  This will most likely involve removing all watch points when
entering the library and replacing them when returning to user code.

@item
Need to add advanced signal information for operating systems that do not
support the @code{siginfo()} system call.  This information is used by the
signal handler that handles the @code{SIGSEGV} signal in order to provide useful
information about where an illegal memory access occurred.  However, there is
currently a problem in that the call stack displayed from within that handler is
not necessarily accurate with respect to the function at the top of the stack.
Also, signal handlers shouldn't technically call I/O functions in case of
additional signals being caught so this may need to be improved.

@item
Need to add a portable way of initialising the thread-safe version of the
library when it is compiled by a C compiler.  There is already a solution to
this problem when it is compiled by a C++ compiler.

@item
Need to add support for call stack traversal for at least the Alpha, MIPS,
PA/RISC and PowerPC processor architectures.  The current implementation of call
stack traversal for the Motorola 88xx0 family is also a bit flaky and so should
only be used when the library and program are built unoptimised.

@item
Need to add support for obtaining the program name from the stack for at least
the Alpha, Motorola 88xx0, MIPS, PA/RISC and PowerPC processor architectures.
Also need to add support for reading the program symbols from a suitable file
in @file{/proc} for other operating systems that support it.  If there is no
support for either of these methods then the @option{PROGFILE} option can
currently be used to specify the program name at run-time.

@item
The library cannot currently read any symbols from shared objects that have been
read via @code{dlopen()}.

@item
The @option{-d} option to the @command{mpatrol} shell script does not always
work on systems whose dynamic linkers support the @env{LD_PRELOAD} environment
variable.  This needs to be looked into in order to find out the cause.
@end itemize

@node Amiga notes, Windows notes, UNIX notes, Notes
@appendixsec Notes for Amiga platforms
@cindex notes for Amiga platforms
@cindex Amiga notes

@itemize @bullet
@item
The supplied SAS/C @file{Makefile} contains support for building the mpatrol
library as a shared library, but this is incomplete and will result in link
errors.  The reason for this is that an Amiga shared library is a separate task
and would need to build itself a process structure before being able to make any
calls to the DOS library.  Perhaps it's not even worth implementing as the
archive library works fine.

@item
All source code that uses the mpatrol library currently needs to be compiled
using the @option{PARMS=BOTH} SAS/C compiler option (or equivalent) in order to
correctly pass arguments to the library.  This is a side-effect of supporting
the shared library as well as the archive library.

@item
Need to add support for call stack traversal for both the Motorola 680x0 and
PowerPC processor architectures.  At first glance, this doesn't seem to be very
easy, or perhaps even impossible.

@item
Need to add support for reading symbols from Amiga executable files.  Also need
to add support for reading symbols from any shared libraries that are required
by the program.  The Amiga executable file format doesn't seem to contain enough
information for this to be worthwhile, and even then it would only be worth
doing if call stack traversal worked.

@item
It is currently not possible to override the definition of @code{malloc()},
etc., without including the @file{mpatrol.h} header file first.  This is because
the compiler startup code and libraries call @code{malloc()} before everything
is set up, and so the library cannot properly initialise itself if the
@code{malloc()} that the startup code finds is the @code{malloc()} in the
mpatrol library.
@end itemize

@node Windows notes, Netware notes, Amiga notes, Notes
@appendixsec Notes for Windows platforms
@cindex notes for Windows platforms
@cindex Windows notes

@itemize @bullet
@item
Need to add watch point area support, possibly by using guard pages as a basis
for an implementation.

@item
Need to add support for reading symbols from Windows executable files.  Also
need to add support for reading symbols from any DLLs that are required by the
program.  This may be possible in a limited fashion by using the GNU BFD
library, but may only work with code compiled with @command{gcc}.

@item
It is currently not possible to override the definitions of @code{malloc()},
etc., without including the @file{mpatrol.h} header file first.  This is because
the system startup code calls @code{malloc()} before anything is set up, such as
streams, and so the library cannot properly initialise itself if the
@code{malloc()} that the startup code finds is the @code{malloc()} in the
mpatrol library.
@end itemize

@node Netware notes, , Windows notes, Notes
@appendixsec Notes for Netware platforms
@cindex notes for Netware platforms
@cindex Netware notes

@itemize @bullet
@item
The library has not yet been built (let alone tested) on Netware platforms.  The
names of the system functions that the library calls for Netware were obtained
by looking at Novell's developer documentation, so they may not even compile
correctly without modification.

@item
Need to add support for building the mpatrol library as an NLM.  This is not
currently a high priority requirement as the archive library should suffice for
most purposes.

@item
Need to add way to determine when the base of the stack has been reached during
call stack traversal, since on Netware every application is really a thread
running under one large process.

@item
Need to add support for reading symbols from Netware load modules.  Also need to
add support for reading symbols from any NLMs that are required by the program.
This may be possible in a limited fashion by using the GNU BFD library, but may
only work with code compiled with @command{gcc}.

@item
Need to investigate if it is safe (or even possible) to override the definitions
of @code{malloc()}, etc., without including the @file{mpatrol.h} header file
first.  Currently, non-macro definitions for these functions have been disabled
in the Netware version of the library in case they affect other NLMs that are
currently running.
@end itemize

@node Related software, Function index, Notes, Top
@appendix Related software
@cindex related software
@cindex software
@cindex other programs
@cindex similar programs
@cindex programs

A list of software which helps in debugging dynamic memory allocation problems
is given below@footnote{This list can be considered to be a slightly more up to
date version of @cite{Debugging Tools for Dynamic Storage Allocation and Memory
Management} (@uref{http://www.cs.colorado.edu/~zorn/MallocDebug.html}) by Ben
Zorn (@email{zorn@@cs.colorado.edu}).}.  They all provide some of the features
that mpatrol contains and you may wish to use one of them to solve your problem
if you have trouble using mpatrol.  I have only ever used Dbmalloc and Electric
Fence, so I can't vouch for any of the others, although if you have any
recommendations feel free to let me know so I can add them to this list.  In
particular, there seems to be a shortage of such programs for AmigaOS and
Netware platforms.

@cindex BoundsChecker
@cindex NuMega Corporation
@itemize @bullet
@item
BoundsChecker
@table @asis
@item Author
NuMega Corporation (@email{info@@numega.com})
@item License
Commercial Software
@item Platforms
MS-DOS, Windows
@item Location
@uref{http://www.numega.com/}
@item Overview
Detects and diagnoses errors in static, stack and heap memory and in memory and
resource leaks.
@end table

@cindex Ccmalloc
@cindex Biere, Armin
@item
Ccmalloc
@table @asis
@item Author
Armin Biere (@email{armin@@ira.uk.de})
@item License
GNU General Public License
@item Platforms
Various UNIX
@item Location
@uref{http://iseran.ira.uka.de/~armin/ccmalloc/}
@item Overview
Can interface with @command{gdb} to find memory leaks, multiple deallocations
and memory corruptions in C or C++ programs.
@end table

@cindex Checker
@cindex Gingold, Tristan
@item
Checker
@table @asis
@item Author
Tristan Gingold (@email{bug-checker@@gnu.org})
@item License
GNU General Public License
@item Platforms
Various UNIX
@item Location
@uref{http://www.gnu.org/}
@item Overview
Detects illegal memory accesses when reading from uninitialised memory, writing
to freed memory or outside memory blocks.  Also contains a garbage collector for
detecting memory leaks.
@end table

@cindex Dbmalloc
@cindex Cahill, Conor P.
@item
Dbmalloc
@table @asis
@item Author
Conor P. Cahill (@email{cpcahil@@virtech.vti.com})
@item License
Free Software
@item Platforms
Various UNIX
@item Location
@uref{http://www.clark.net/pub/dickey/dbmalloc/dbmalloc.html}
@item Overview
Provides replacements for memory management library functions and provides a
full set of debugging features which detect memory overruns and other types of
misuse.
@end table

@cindex Dmalloc
@cindex Watson, Gray
@item
Dmalloc
@table @asis
@item Author
Gray Watson (@email{gray@@burger.letters.com})
@item License
Free Software
@item Platforms
Various UNIX, MS-DOS, Windows
@item Location
@uref{http://www.dmalloc.com/}
@item Overview
A drop-in replacement for the system's memory management routines, providing
powerful debugging facilities configurable at run-time.
@end table

@cindex Electric Fence
@cindex Perens, Bruce
@item
Electric Fence
@table @asis
@item Author
Bruce Perens (@email{Bruce@@Pixar.com})
@item License
GNU General Public License
@item Platforms
Various UNIX
@item Location
@uref{ftp://ftp.perens.com/pub/ElectricFence/}
@item Overview
Uses virtual memory hardware to protect dynamically allocated memory in order to
detect illegal memory accesses.
@end table

@cindex FDA (Free Debug Allocator)
@cindex Helvey, Thomas
@item
FDA (Free Debug Allocator)
@table @asis
@item Author
Thomas Helvey (@email{tomh@@inxpress.net})
@item License
GNU General Public License
@item Platforms
Linux, Windows
@item Location
@uref{http://www.debian.org/Packages/unstable/devel/fda.html}
@item Overview
Provides routines that can be plugged in to replace @code{malloc()},
@code{calloc()}, @code{realloc()} and @code{free()}.
@end table

@cindex GC (Garbage Collector)
@cindex Boehm, Hans-J.
@item
GC (Garbage Collector)
@table @asis
@item Author
Hans-J. Boehm (@email{boehm@@acm.org})
@item License
Free Software
@item Platforms
Various UNIX, AmigaOS, MS-DOS, Windows, MacOS
@item Location
@uref{http://www.hpl.hp.com/personal/Hans_Boehm/gc/}
@item Overview
A general-purpose, garbage-collecting storage allocator that is intended to be
used as a plug-in replacement for @code{malloc()}, but can also be used to
detect memory leaks.
@end table

@cindex Great Circle
@cindex Geodesic Systems
@item
Great Circle
@table @asis
@item Author
Geodesic Systems (@email{info@@geodesic.com})
@item License
Commercial Software
@item Platforms
Various UNIX, Windows
@item Location
@uref{http://www.geodesic.com/}
@item Overview
Provides complete heap profiling, allowing programmers to see what parts of a
program are using the most memory with symbolic stack tracing.
@end table

@cindex HeapAgent
@cindex MicroQuill
@item
HeapAgent
@table @asis
@item Author
MicroQuill (@email{info@@microquill.com})
@item License
Commercial Software
@item Platforms
Windows
@item Location
@uref{http://www.microquill.com/}
@item Overview
Instruments the heap to provide heap error detection without the need to
recompile any source code.
@end table

@cindex Insure++
@cindex Parasoft
@item
Insure++
@table @asis
@item Author
ParaSoft (@email{info@@parasoft.com})
@item License
Commercial Software
@item Platforms
Various UNIX, Windows
@item Location
@uref{http://www.parasoft.com/}
@item Overview
Uses Source Code Instrumentation and Runtime Pointer Tracking technologies to
pinpoint memory corruption, memory leaks, operations on unrelated pointers and
more.
@end table

@cindex MemCheck
@cindex Stratosware Corporation
@item
MemCheck
@table @asis
@item Author
Stratosware Corporation (@email{info@@stratosware.com})
@item License
Commercial Software
@item Platforms
Windows
@item Location
@uref{http://www.stratosware.com/}
@item Overview
Detects various run-time errors related to operating system resources and
provides information on memory leaks.
@end table

@cindex MemDebug
@cindex Schmit, Rene
@item
MemDebug
@table @asis
@item Author
Rene Schmit (@email{rene.schmit@@crpht.lu})
@item License
Free Software
@item Platforms
Various UNIX, MS-DOS, Windows, MacOS
@item Location
@uref{ftp://ftp.crpht.lu/pub/sources/memdebug/}
@item Overview
Provides memory management error detection, memory usage error detection, memory
usage profiling and error simulation.
@end table

@cindex Memory Advisor
@cindex PLATINUM Technology
@item
Memory Advisor
@table @asis
@item Author
PLATINUM Technology (@email{info@@platinum.com})
@item License
Commercial Software
@item Platforms
Various UNIX
@item Location
@uref{http://www.platinum.com/}
@item Overview
Disassembles an object module into system-independent assembler code, inserts
error checking instructions, then re-assembles the code.  Can also replace
existing malloc libraries in order to provide greater error checking.
@end table

@cindex Mmalloc
@cindex Haertel, Mike
@cindex Fish, Fred
@item
Mmalloc
@table @asis
@item Author
Mike Haertel (@email{mike@@ai.mit.edu}) and Fred Fish (@email{fnf@@cygnus.com})
@item License
GNU General Public License
@item Platforms
Various UNIX
@item Location
@uref{http://www.gnu.org/}
@item Overview
Uses @code{mmap()} to allocate separate pools of memory which can be mapped onto
files for later reuse.
@end table

@cindex Mprof
@cindex Zorn, Ben
@item
Mprof
@table @asis
@item Author
Ben Zorn (@email{zorn@@cs.colorado.edu})
@item License
Free Software
@item Platforms
Various UNIX
@item Location
@uref{ftp://gatekeeper.dec.com/pub/misc/mprof-3.0.tar.Z}
@item Overview
Profiles the dynamic memory allocation behaviour of programs by logging details
for each function than makes a memory allocation, including call stack
tracebacks.
@end table

@cindex Purify
@cindex Rational Software
@item
Purify
@table @asis
@item Author
Rational Software (@email{info@@rational.com})
@item License
Commercial Software
@item Platforms
Various UNIX, Windows
@item Location
@uref{http://www.rational.com/}
@item Overview
Uses Object Code Insertion technology to provide run-time error checking and
memory leak detection.
@end table

@cindex QC
@cindex Onyx Technology
@item
QC
@table @asis
@item Author
Onyx Technology (@email{sales@@onyx-tech.com})
@item License
Commercial Software
@item Platforms
MacOS
@item Location
@uref{http://www.onyx-tech.com/}
@item Overview
Runs in the background as a control panel and detects various memory errors
which can then be caught and run under a debugger.
@end table

@cindex ZeroFault
@cindex Kernel Group, The
@item
ZeroFault
@table @asis
@item Author
The Kernel Group (@email{info@@zerofault.com})
@item License
Commercial Software
@item Platforms
AIX UNIX
@item Location
@uref{http://www.zerofault.com/}
@item Overview
Uses run-time emulator technology to provide run-time error checking and memory
leak detection.
@end table
@end itemize

@cindex Solaris 7 malloc libraries
@cindex malloc libraries for Solaris 7
However, before you try out any of the above software, there may already be a
malloc library with debugging support on your system that might be suitable for
solving your problem.  For example, on Solaris 7 the following libraries are
available:

@table @cite
@cindex malloc(3c)
@item malloc(3c)
Trade-off between performance and efficiency.
@cindex malloc(3x)
@item malloc(3x)
Slower performance, space-efficient.
@cindex bsdmalloc(3x)
@item bsdmalloc(3x)
Better performance, space-inefficient.
@cindex mtmalloc(3t)
@item mtmalloc(3t)
Thread-safe memory allocator.
@cindex mapmalloc(3x)
@item mapmalloc(3x)
Uses @code{mmap()} instead of @code{sbrk()} to allocate heap space.
@cindex watchmalloc(3x)
@item watchmalloc(3x)
Uses watch point areas to check for overflows.
@end table

@node Function index, Index, Related software, Top
@unnumbered Function index

@printindex fn

@node Index, , Function index, Top
@unnumbered Index

@printindex cp

@bye
